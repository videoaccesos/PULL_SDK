<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 6.4.2" />
    <title>pyzkaccess.event API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style type="text/css">/*! * Bootstrap Reboot v5.0.0-beta1 (https://getbootstrap.com/) * Copyright 2011-2020 The Bootstrap Authors * Copyright 2011-2020 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}[tabindex="-1"]:focus:not(:focus-visible){outline:0!important}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus{outline:dotted 1px;outline:-webkit-focus-ring-color auto 5px}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style type="text/css">/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style type="text/css">/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main{padding:2rem 3vw;}.git-button{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3, .pdoc h4{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../pyzkaccess.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;pyzkaccess</a>




                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#Event">Event</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Event.__init__">Event</a>
                        </li>
                        <li>
                                <a class="variable" href="#Event.time">time</a>
                        </li>
                        <li>
                                <a class="variable" href="#Event.pin">pin</a>
                        </li>
                        <li>
                                <a class="variable" href="#Event.card">card</a>
                        </li>
                        <li>
                                <a class="variable" href="#Event.door">door</a>
                        </li>
                        <li>
                                <a class="variable" href="#Event.event_type">event_type</a>
                        </li>
                        <li>
                                <a class="variable" href="#Event.entry_exit">entry_exit</a>
                        </li>
                        <li>
                                <a class="variable" href="#Event.verify_mode">verify_mode</a>
                        </li>
                        <li>
                                <a class="variable" href="#Event.description">description</a>
                        </li>
                        <li>
                                <a class="function" href="#Event.parse">parse</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#EventLog">EventLog</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#EventLog.__init__">EventLog</a>
                        </li>
                        <li>
                                <a class="function" href="#EventLog.refresh">refresh</a>
                        </li>
                        <li>
                                <a class="function" href="#EventLog.after_time">after_time</a>
                        </li>
                        <li>
                                <a class="function" href="#EventLog.before_time">before_time</a>
                        </li>
                        <li>
                                <a class="function" href="#EventLog.between_time">between_time</a>
                        </li>
                        <li>
                                <a class="function" href="#EventLog.poll">poll</a>
                        </li>
                        <li>
                                <a class="function" href="#EventLog.only">only</a>
                        </li>
                        <li>
                                <a class="function" href="#EventLog.clear">clear</a>
                        </li>
                </ul>

            </li>
    </ul>


                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20width%3D%22300%22%20height%3D%22150%22%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%3E%0A%0A%20%3Cg%3E%0A%20%20%3Ctitle%3ELayer%201%3C/title%3E%0A%20%20%3Ctext%20transform%3D%22matrix%281%2C%200%2C%200%2C%201%2C%200%2C%200%29%22%20font-style%3D%22normal%22%20font-weight%3D%22normal%22%20xml%3Aspace%3D%22preserve%22%20text-anchor%3D%22start%22%20font-family%3D%22serif%22%20font-size%3D%2247%22%20id%3D%22svg_2%22%20y%3D%2291.5%22%20x%3D%2217.20833%22%20opacity%3D%22undefined%22%20stroke-width%3D%220%22%20stroke%3D%22%23000%22%20fill%3D%22%23000000%22%3Epyzkaccess%3C/text%3E%0A%20%3C/g%3E%0A%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../pyzkaccess.html">pyzkaccess</a>.event    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;Event&#39;</span><span class="p">,</span>
    <span class="s1">&#39;EventLog&#39;</span>
<span class="p">]</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="kn">from</span> <span class="nn">.common</span> <span class="kn">import</span> <span class="n">DocValue</span>
<span class="kn">from</span> <span class="nn">.enums</span> <span class="kn">import</span> <span class="n">VerifyMode</span><span class="p">,</span> <span class="n">PassageDirection</span><span class="p">,</span> <span class="n">EVENT_TYPES</span>
<span class="kn">from</span> <span class="nn">.sdk</span> <span class="kn">import</span> <span class="n">ZKSDK</span>


<span class="k">class</span> <span class="nc">Event</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One realtime event occured on the device</span>
<span class="sd">    Since the device returns event as string we need to parse it to the</span>
<span class="sd">    structured view. This class does this.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;time&#39;</span><span class="p">,</span>
        <span class="s1">&#39;pin&#39;</span><span class="p">,</span>
        <span class="s1">&#39;card&#39;</span><span class="p">,</span>
        <span class="s1">&#39;door&#39;</span><span class="p">,</span>
        <span class="s1">&#39;event_type&#39;</span><span class="p">,</span>
        <span class="s1">&#39;entry_exit&#39;</span><span class="p">,</span>
        <span class="s1">&#39;verify_mode&#39;</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param s: Event string to be parsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>  <span class="c1"># type: datetime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pin</span> <span class="o">=</span> <span class="n">parsed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># type: str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">card</span> <span class="o">=</span> <span class="n">parsed</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># type: str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">door</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># type: int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">EVENT_TYPES</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>  <span class="c1"># type: DocValue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entry_exit</span> <span class="o">=</span> <span class="n">PassageDirection</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span>  <span class="c1"># type: PassageDirection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">VerifyMode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">6</span><span class="p">]))</span>  <span class="c1"># type: VerifyMode</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Event[</span><span class="si">{}</span><span class="s1">]: &quot;</span><span class="si">{}</span><span class="s1">&quot; at door &quot;</span><span class="si">{}</span><span class="s1">&quot; for card &quot;</span><span class="si">{}</span><span class="s1">&quot; -- </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_type</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">door</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">card</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entry_exit</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">event_line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse raw event string</span>
<span class="sd">        :param event_line: event string</span>
<span class="sd">        :return: parsed string parts of event string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">event_line</span> <span class="o">=</span> <span class="n">event_line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">items</span> <span class="o">=</span> <span class="n">event_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Event string must have exactly 7 parts: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">event_line</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">items</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Event</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Event(&#39;</span> \
               <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">)</span> \
               <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">EventLog</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Log of realtime events</span>

<span class="sd">    Keep in mind that log is not filled out automatically and</span>
<span class="sd">    should be refreshed periodically by hand using `refresh()`</span>
<span class="sd">    method. This is because working with ZKAccess has</span>
<span class="sd">    request-response nature and cannot up a tunnel which may be</span>
<span class="sd">    used to feed events.</span>

<span class="sd">    But you can use `poll()` method which awaits new events from</span>
<span class="sd">    a device and return them if any.</span>

<span class="sd">    Log is implemented at top of deque structure, so accessing by</span>
<span class="sd">    index and filtering could be slow.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">sdk</span><span class="p">:</span> <span class="n">ZKSDK</span><span class="p">,</span>
                 <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">maxlen</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">only_filters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">deque</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">_data</span> <span class="k">if</span> <span class="n">_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">maxlen</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span> <span class="o">=</span> <span class="n">only_filters</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sdk</span> <span class="o">=</span> <span class="n">sdk</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Make a request to a device for new records and append to the</span>
<span class="sd">        end if any.</span>
<span class="sd">        :return: count of records which was added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ZKAccess always returns single event with code 255</span>
        <span class="c1"># on every log query if no other events occured. So, skip it</span>
        <span class="n">new_events</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pull_events</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">event_type</span> <span class="o">!=</span> <span class="mi">255</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">new_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_events</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="n">new_events</span><span class="p">))</span>
            <span class="n">new_events</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pull_events</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">event_type</span> <span class="o">!=</span> <span class="mi">255</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">after_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">after_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return events which was occured after given time</span>
<span class="sd">        :param after_time: datetime object to filter (included)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">after_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">before_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return events which was occured before given time</span>
<span class="sd">        :param before_time: datetime object to filter (excluded)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">before_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">between_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">to_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return events which was occured between two given time moments</span>
<span class="sd">        :param from_time: datetime object to filter (included)</span>
<span class="sd">        :param to_time: datetime object to filter (excluded)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">from_time</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">to_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span> <span class="n">polling_interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wait for new events by making periodically requests to a device.</span>
<span class="sd">        If events was appeared then return them. If no event was</span>
<span class="sd">        appeared until timeout was expired then return empty iterable.</span>
<span class="sd">        :param timeout: timeout in seconds. Default: 60 seconds</span>
<span class="sd">        :param polling_interval: interval to make a requests in seconds.</span>
<span class="sd">         Default: every 1 second</span>
<span class="sd">        :return: iterable with new events if any or empty iterable if</span>
<span class="sd">         timeout has expired</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deadline</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
        <span class="k">while</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">deadline</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>  <span class="c1"># Can run up to several seconds depending on network</span>
            <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
                <span class="n">reversed_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">reversed_events</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">polling_interval</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">only</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;EventLog&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new EventLog instance with given filters applied.</span>
<span class="sd">        Kwargs names must be the same as Event slots.</span>

<span class="sd">        Event log returned by this method will contain entries in</span>
<span class="sd">        which attribute value is contained in appropriate filter</span>
<span class="sd">        (if any).</span>

<span class="sd">        Filters passed here will be ANDed during comparison. On</span>
<span class="sd">        repeatable call of only, given filters which was also set</span>
<span class="sd">        on previous call will be ORed, i.e. their values will be</span>
<span class="sd">        concatenated.</span>

<span class="sd">        In other words:</span>

<span class="sd">        ```log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;])` =&gt; filtering(entry.a == 2 AND entry.b in (&#39;x&#39;, &#39;y&#39;))```</span>

<span class="sd">        ```log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;]).only(a=3, b=5, c=1) =&gt;</span>
<span class="sd">            filtering(entry.a in (2, 3) AND entry.b in (&#39;x&#39;, &#39;y&#39;, 5) and entry.c == 1)```</span>

<span class="sd">        Ex: `new_log = log.only(door=1, event_type=221)`</span>
<span class="sd">        :param filters:</span>
<span class="sd">        :return: new fitlered EventLog instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">only_filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_filters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span><span class="p">,</span> <span class="n">filters</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sdk</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">maxlen</span><span class="p">,</span>
                             <span class="n">only_filters</span><span class="p">,</span>
                             <span class="n">_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Clear log&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_merge_filters</span><span class="p">(</span><span class="n">initial</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">fltr</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge two filter dicts, fltr updates initial. Key-values  which</span>
<span class="sd">        does not exist in initial will be copied. Value of existent</span>
<span class="sd">        keys are combined (values always are lists).</span>
<span class="sd">        :param initial: updating initial filter dict</span>
<span class="sd">        :param fltr: filter dict which updates initial</span>
<span class="sd">        :return: merged filter dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seq_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">fltr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">seq_types</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">{</span><span class="n">value</span><span class="p">}</span>

            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply current filters to given events and return only events</span>
<span class="sd">        which meet them</span>
<span class="sd">        :param data: unfiltered events</span>
<span class="sd">        :return: filtered events</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">data</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">event</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_match</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span> <span class="ow">in</span> <span class="n">fltr</span>
                                <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">fltr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">all_match</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">event</span>

    <span class="k">def</span> <span class="nf">_pull_events</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sdk</span><span class="o">.</span><span class="n">get_rt_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Event</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">events</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">],</span> <span class="n">Event</span><span class="p">]:</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Index is out of range&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">step</span>
        <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">items_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">items_str</span> <span class="o">+=</span> <span class="s1">&#39;, ..., &#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>
        <span class="k">return</span> <span class="s1">&#39;EventLog[</span><span class="si">{}</span><span class="s1">](</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">items_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
</pre></div>

        </details>

            </section>
                <section id="Event">
                                <div class="attr class">
        <a class="headerlink" href="#Event">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Event</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Event</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One realtime event occured on the device</span>
<span class="sd">    Since the device returns event as string we need to parse it to the</span>
<span class="sd">    structured view. This class does this.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;time&#39;</span><span class="p">,</span>
        <span class="s1">&#39;pin&#39;</span><span class="p">,</span>
        <span class="s1">&#39;card&#39;</span><span class="p">,</span>
        <span class="s1">&#39;door&#39;</span><span class="p">,</span>
        <span class="s1">&#39;event_type&#39;</span><span class="p">,</span>
        <span class="s1">&#39;entry_exit&#39;</span><span class="p">,</span>
        <span class="s1">&#39;verify_mode&#39;</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param s: Event string to be parsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>  <span class="c1"># type: datetime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pin</span> <span class="o">=</span> <span class="n">parsed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># type: str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">card</span> <span class="o">=</span> <span class="n">parsed</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># type: str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">door</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># type: int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">EVENT_TYPES</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>  <span class="c1"># type: DocValue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entry_exit</span> <span class="o">=</span> <span class="n">PassageDirection</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span>  <span class="c1"># type: PassageDirection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">VerifyMode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">6</span><span class="p">]))</span>  <span class="c1"># type: VerifyMode</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Event[</span><span class="si">{}</span><span class="s1">]: &quot;</span><span class="si">{}</span><span class="s1">&quot; at door &quot;</span><span class="si">{}</span><span class="s1">&quot; for card &quot;</span><span class="si">{}</span><span class="s1">&quot; -- </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_type</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">door</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">card</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entry_exit</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">event_line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse raw event string</span>
<span class="sd">        :param event_line: event string</span>
<span class="sd">        :return: parsed string parts of event string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">event_line</span> <span class="o">=</span> <span class="n">event_line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">items</span> <span class="o">=</span> <span class="n">event_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Event string must have exactly 7 parts: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">event_line</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">items</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Event</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Event(&#39;</span> \
               <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">)</span> \
               <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>One realtime event occured on the device
Since the device returns event as string we need to parse it to the
structured view. This class does this.</p>
</div>


                            <div id="Event.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Event.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Event</span><span class="signature">(s)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param s: Event string to be parsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>  <span class="c1"># type: datetime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pin</span> <span class="o">=</span> <span class="n">parsed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># type: str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">card</span> <span class="o">=</span> <span class="n">parsed</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># type: str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">door</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># type: int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">EVENT_TYPES</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>  <span class="c1"># type: DocValue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entry_exit</span> <span class="o">=</span> <span class="n">PassageDirection</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span>  <span class="c1"># type: PassageDirection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">VerifyMode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="mi">6</span><span class="p">]))</span>  <span class="c1"># type: VerifyMode</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param s: Event string to be parsed.</p>
</div>


                            </div>
                            <div id="Event.time" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Event.time">#&nbsp;&nbsp</a>

        <span class="name">time</span><span class="default_value"> = &lt;member &#39;time&#39; of &#39;Event&#39; objects&gt;</span>
    </div>

    

                            </div>
                            <div id="Event.pin" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Event.pin">#&nbsp;&nbsp</a>

        <span class="name">pin</span><span class="default_value"> = &lt;member &#39;pin&#39; of &#39;Event&#39; objects&gt;</span>
    </div>

    

                            </div>
                            <div id="Event.card" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Event.card">#&nbsp;&nbsp</a>

        <span class="name">card</span><span class="default_value"> = &lt;member &#39;card&#39; of &#39;Event&#39; objects&gt;</span>
    </div>

    

                            </div>
                            <div id="Event.door" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Event.door">#&nbsp;&nbsp</a>

        <span class="name">door</span><span class="default_value"> = &lt;member &#39;door&#39; of &#39;Event&#39; objects&gt;</span>
    </div>

    

                            </div>
                            <div id="Event.event_type" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Event.event_type">#&nbsp;&nbsp</a>

        <span class="name">event_type</span><span class="default_value"> = &lt;member &#39;event_type&#39; of &#39;Event&#39; objects&gt;</span>
    </div>

    

                            </div>
                            <div id="Event.entry_exit" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Event.entry_exit">#&nbsp;&nbsp</a>

        <span class="name">entry_exit</span><span class="default_value"> = &lt;member &#39;entry_exit&#39; of &#39;Event&#39; objects&gt;</span>
    </div>

    

                            </div>
                            <div id="Event.verify_mode" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Event.verify_mode">#&nbsp;&nbsp</a>

        <span class="name">verify_mode</span><span class="default_value"> = &lt;member &#39;verify_mode&#39; of &#39;Event&#39; objects&gt;</span>
    </div>

    

                            </div>
                            <div id="Event.description" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Event.description">#&nbsp;&nbsp</a>

        <span class="name">description</span><span class="annotation">: str</span>
    </div>

    

                            </div>
                            <div id="Event.parse" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Event.parse">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">parse</span><span class="signature">(event_line: str) -&gt; Sequence[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">event_line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse raw event string</span>
<span class="sd">        :param event_line: event string</span>
<span class="sd">        :return: parsed string parts of event string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">event_line</span> <span class="o">=</span> <span class="n">event_line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">items</span> <span class="o">=</span> <span class="n">event_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Event string must have exactly 7 parts: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">event_line</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">items</span>
</pre></div>

        </details>

            <div class="docstring"><p>Parse raw event string
:param event_line: event string
:return: parsed string parts of event string</p>
</div>


                            </div>
                </section>
                <section id="EventLog">
                                <div class="attr class">
        <a class="headerlink" href="#EventLog">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">EventLog</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">EventLog</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Log of realtime events</span>

<span class="sd">    Keep in mind that log is not filled out automatically and</span>
<span class="sd">    should be refreshed periodically by hand using `refresh()`</span>
<span class="sd">    method. This is because working with ZKAccess has</span>
<span class="sd">    request-response nature and cannot up a tunnel which may be</span>
<span class="sd">    used to feed events.</span>

<span class="sd">    But you can use `poll()` method which awaits new events from</span>
<span class="sd">    a device and return them if any.</span>

<span class="sd">    Log is implemented at top of deque structure, so accessing by</span>
<span class="sd">    index and filtering could be slow.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">sdk</span><span class="p">:</span> <span class="n">ZKSDK</span><span class="p">,</span>
                 <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">maxlen</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">only_filters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">deque</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">_data</span> <span class="k">if</span> <span class="n">_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">maxlen</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span> <span class="o">=</span> <span class="n">only_filters</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sdk</span> <span class="o">=</span> <span class="n">sdk</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Make a request to a device for new records and append to the</span>
<span class="sd">        end if any.</span>
<span class="sd">        :return: count of records which was added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ZKAccess always returns single event with code 255</span>
        <span class="c1"># on every log query if no other events occured. So, skip it</span>
        <span class="n">new_events</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pull_events</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">event_type</span> <span class="o">!=</span> <span class="mi">255</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">new_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_events</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="n">new_events</span><span class="p">))</span>
            <span class="n">new_events</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pull_events</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">event_type</span> <span class="o">!=</span> <span class="mi">255</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">after_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">after_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return events which was occured after given time</span>
<span class="sd">        :param after_time: datetime object to filter (included)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">after_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">before_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return events which was occured before given time</span>
<span class="sd">        :param before_time: datetime object to filter (excluded)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">before_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">between_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">to_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return events which was occured between two given time moments</span>
<span class="sd">        :param from_time: datetime object to filter (included)</span>
<span class="sd">        :param to_time: datetime object to filter (excluded)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">from_time</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">to_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span> <span class="n">polling_interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wait for new events by making periodically requests to a device.</span>
<span class="sd">        If events was appeared then return them. If no event was</span>
<span class="sd">        appeared until timeout was expired then return empty iterable.</span>
<span class="sd">        :param timeout: timeout in seconds. Default: 60 seconds</span>
<span class="sd">        :param polling_interval: interval to make a requests in seconds.</span>
<span class="sd">         Default: every 1 second</span>
<span class="sd">        :return: iterable with new events if any or empty iterable if</span>
<span class="sd">         timeout has expired</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deadline</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
        <span class="k">while</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">deadline</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>  <span class="c1"># Can run up to several seconds depending on network</span>
            <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
                <span class="n">reversed_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">reversed_events</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">polling_interval</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">only</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;EventLog&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new EventLog instance with given filters applied.</span>
<span class="sd">        Kwargs names must be the same as Event slots.</span>

<span class="sd">        Event log returned by this method will contain entries in</span>
<span class="sd">        which attribute value is contained in appropriate filter</span>
<span class="sd">        (if any).</span>

<span class="sd">        Filters passed here will be ANDed during comparison. On</span>
<span class="sd">        repeatable call of only, given filters which was also set</span>
<span class="sd">        on previous call will be ORed, i.e. their values will be</span>
<span class="sd">        concatenated.</span>

<span class="sd">        In other words:</span>

<span class="sd">        ```log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;])` =&gt; filtering(entry.a == 2 AND entry.b in (&#39;x&#39;, &#39;y&#39;))```</span>

<span class="sd">        ```log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;]).only(a=3, b=5, c=1) =&gt;</span>
<span class="sd">            filtering(entry.a in (2, 3) AND entry.b in (&#39;x&#39;, &#39;y&#39;, 5) and entry.c == 1)```</span>

<span class="sd">        Ex: `new_log = log.only(door=1, event_type=221)`</span>
<span class="sd">        :param filters:</span>
<span class="sd">        :return: new fitlered EventLog instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">only_filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_filters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span><span class="p">,</span> <span class="n">filters</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sdk</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">maxlen</span><span class="p">,</span>
                             <span class="n">only_filters</span><span class="p">,</span>
                             <span class="n">_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Clear log&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_merge_filters</span><span class="p">(</span><span class="n">initial</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">fltr</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge two filter dicts, fltr updates initial. Key-values  which</span>
<span class="sd">        does not exist in initial will be copied. Value of existent</span>
<span class="sd">        keys are combined (values always are lists).</span>
<span class="sd">        :param initial: updating initial filter dict</span>
<span class="sd">        :param fltr: filter dict which updates initial</span>
<span class="sd">        :return: merged filter dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seq_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">fltr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">seq_types</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">{</span><span class="n">value</span><span class="p">}</span>

            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply current filters to given events and return only events</span>
<span class="sd">        which meet them</span>
<span class="sd">        :param data: unfiltered events</span>
<span class="sd">        :return: filtered events</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">data</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">event</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_match</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span> <span class="ow">in</span> <span class="n">fltr</span>
                                <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">fltr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">all_match</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">event</span>

    <span class="k">def</span> <span class="nf">_pull_events</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sdk</span><span class="o">.</span><span class="n">get_rt_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Event</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">events</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">],</span> <span class="n">Event</span><span class="p">]:</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Index is out of range&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">step</span>
        <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">items_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">items_str</span> <span class="o">+=</span> <span class="s1">&#39;, ..., &#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>
        <span class="k">return</span> <span class="s1">&#39;EventLog[</span><span class="si">{}</span><span class="s1">](</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">items_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Log of realtime events</p>

<p>Keep in mind that log is not filled out automatically and
should be refreshed periodically by hand using <code><a href="#EventLog.refresh">refresh()</a></code>
method. This is because working with ZKAccess has
request-response nature and cannot up a tunnel which may be
used to feed events.</p>

<p>But you can use <code><a href="#EventLog.poll">poll()</a></code> method which awaits new events from
a device and return them if any.</p>

<p>Log is implemented at top of deque structure, so accessing by
index and filtering could be slow.</p>
</div>


                            <div id="EventLog.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#EventLog.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">EventLog</span><span class="signature">(
    sdk: <a href="sdk.html#ZKSDK">pyzkaccess.sdk.ZKSDK</a>,
    buffer_size: int,
    maxlen: Union[int, NoneType] = None,
    only_filters: Union[dict, NoneType] = None,
    _data: Union[collections.deque, NoneType] = None
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">sdk</span><span class="p">:</span> <span class="n">ZKSDK</span><span class="p">,</span>
                 <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">maxlen</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">only_filters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">deque</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">_data</span> <span class="k">if</span> <span class="n">_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">maxlen</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span> <span class="o">=</span> <span class="n">only_filters</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sdk</span> <span class="o">=</span> <span class="n">sdk</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="EventLog.refresh" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#EventLog.refresh">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">refresh</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Make a request to a device for new records and append to the</span>
<span class="sd">        end if any.</span>
<span class="sd">        :return: count of records which was added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ZKAccess always returns single event with code 255</span>
        <span class="c1"># on every log query if no other events occured. So, skip it</span>
        <span class="n">new_events</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pull_events</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">event_type</span> <span class="o">!=</span> <span class="mi">255</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">new_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_events</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="n">new_events</span><span class="p">))</span>
            <span class="n">new_events</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pull_events</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">event_type</span> <span class="o">!=</span> <span class="mi">255</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">count</span>
</pre></div>

        </details>

            <div class="docstring"><p>Make a request to a device for new records and append to the
end if any.
:return: count of records which was added</p>
</div>


                            </div>
                            <div id="EventLog.after_time" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#EventLog.after_time">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">after_time</span><span class="signature">(
    self,
    after_time: datetime.datetime
) -&gt; Iterable[<a href="#Event">pyzkaccess.event.Event</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">after_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">after_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return events which was occured after given time</span>
<span class="sd">        :param after_time: datetime object to filter (included)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">after_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return events which was occured after given time
:param after_time: datetime object to filter (included)
:return:</p>
</div>


                            </div>
                            <div id="EventLog.before_time" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#EventLog.before_time">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">before_time</span><span class="signature">(
    self,
    before_time: datetime.datetime
) -&gt; Iterable[<a href="#Event">pyzkaccess.event.Event</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">before_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return events which was occured before given time</span>
<span class="sd">        :param before_time: datetime object to filter (excluded)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">before_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return events which was occured before given time
:param before_time: datetime object to filter (excluded)
:return:</p>
</div>


                            </div>
                            <div id="EventLog.between_time" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#EventLog.between_time">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">between_time</span><span class="signature">(
    self,
    from_time: datetime.datetime,
    to_time: datetime.datetime
) -&gt; Iterable[<a href="#Event">pyzkaccess.event.Event</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">between_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">to_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return events which was occured between two given time moments</span>
<span class="sd">        :param from_time: datetime object to filter (included)</span>
<span class="sd">        :param to_time: datetime object to filter (excluded)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">from_time</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">to_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return events which was occured between two given time moments
:param from_time: datetime object to filter (included)
:param to_time: datetime object to filter (excluded)
:return:</p>
</div>


                            </div>
                            <div id="EventLog.poll" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#EventLog.poll">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">poll</span><span class="signature">(
    self,
    timeout: float = 60,
    polling_interval: float = 1
) -&gt; List[<a href="#Event">pyzkaccess.event.Event</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span> <span class="n">polling_interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Event</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wait for new events by making periodically requests to a device.</span>
<span class="sd">        If events was appeared then return them. If no event was</span>
<span class="sd">        appeared until timeout was expired then return empty iterable.</span>
<span class="sd">        :param timeout: timeout in seconds. Default: 60 seconds</span>
<span class="sd">        :param polling_interval: interval to make a requests in seconds.</span>
<span class="sd">         Default: every 1 second</span>
<span class="sd">        :return: iterable with new events if any or empty iterable if</span>
<span class="sd">         timeout has expired</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deadline</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
        <span class="k">while</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">deadline</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>  <span class="c1"># Can run up to several seconds depending on network</span>
            <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
                <span class="n">reversed_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_events</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">reversed_events</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">polling_interval</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Wait for new events by making periodically requests to a device.
If events was appeared then return them. If no event was
appeared until timeout was expired then return empty iterable.
:param timeout: timeout in seconds. Default: 60 seconds
:param polling_interval: interval to make a requests in seconds.
 Default: every 1 second
:return: iterable with new events if any or empty iterable if
 timeout has expired</p>
</div>


                            </div>
                            <div id="EventLog.only" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#EventLog.only">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">only</span><span class="signature">(self, **filters) -&gt; <a href="#EventLog">pyzkaccess.event.EventLog</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">only</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;EventLog&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new EventLog instance with given filters applied.</span>
<span class="sd">        Kwargs names must be the same as Event slots.</span>

<span class="sd">        Event log returned by this method will contain entries in</span>
<span class="sd">        which attribute value is contained in appropriate filter</span>
<span class="sd">        (if any).</span>

<span class="sd">        Filters passed here will be ANDed during comparison. On</span>
<span class="sd">        repeatable call of only, given filters which was also set</span>
<span class="sd">        on previous call will be ORed, i.e. their values will be</span>
<span class="sd">        concatenated.</span>

<span class="sd">        In other words:</span>

<span class="sd">        ```log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;])` =&gt; filtering(entry.a == 2 AND entry.b in (&#39;x&#39;, &#39;y&#39;))```</span>

<span class="sd">        ```log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;]).only(a=3, b=5, c=1) =&gt;</span>
<span class="sd">            filtering(entry.a in (2, 3) AND entry.b in (&#39;x&#39;, &#39;y&#39;, 5) and entry.c == 1)```</span>

<span class="sd">        Ex: `new_log = log.only(door=1, event_type=221)`</span>
<span class="sd">        :param filters:</span>
<span class="sd">        :return: new fitlered EventLog instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">only_filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_filters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">only_filters</span><span class="p">,</span> <span class="n">filters</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sdk</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">maxlen</span><span class="p">,</span>
                             <span class="n">only_filters</span><span class="p">,</span>
                             <span class="n">_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return new EventLog instance with given filters applied.
Kwargs names must be the same as Event slots.</p>

<p>Event log returned by this method will contain entries in
which attribute value is contained in appropriate filter
(if any).</p>

<p>Filters passed here will be ANDed during comparison. On
repeatable call of only, given filters which was also set
on previous call will be ORed, i.e. their values will be
concatenated.</p>

<p>In other words:</p>

<p><code>log.only(a=2, b=['x', 'y'])` =&gt; filtering(entry.a == 2 AND entry.b in ('x', 'y'))</code></p>

<p><code>log.only(a=2, b=['x', 'y']).only(a=3, b=5, c=1) =&gt;
    filtering(entry.a in (2, 3) AND entry.b in ('x', 'y', 5) and entry.c == 1)</code></p>

<p>Ex: <code>new_log = log.only(door=1, event_type=221)</code>
:param filters:
:return: new fitlered EventLog instance</p>
</div>


                            </div>
                            <div id="EventLog.clear" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#EventLog.clear">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">clear</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Clear log&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Clear log</p>
</div>


                            </div>
                </section>
    </main>
</body>
</html>