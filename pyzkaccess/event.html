<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyzkaccess.event API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyzkaccess.event</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__all__ = [
    &#39;Event&#39;,
    &#39;EventLog&#39;
]
import itertools
import time
from collections import deque
from copy import deepcopy
from datetime import datetime
from typing import Optional, List, Iterable, Union, Sequence

from .common import DocValue, ZKDatetimeUtils
from .enums import VerifyMode, PassageDirection, EVENT_TYPES
from .sdk import ZKSDK


class Event:
    &#34;&#34;&#34;One realtime event occured on the device
    Since the device returns event as string we need to parse it to the
    structured view. This class does this.
    &#34;&#34;&#34;
    __slots__ = (
        &#39;time&#39;,
        &#39;pin&#39;,
        &#39;card&#39;,
        &#39;door&#39;,
        &#39;event_type&#39;,
        &#39;entry_exit&#39;,
        &#39;verify_mode&#39;
    )

    def __init__(self, s: str):
        &#34;&#34;&#34;
        Args:
            s (str): Event string to be parsed.

        &#34;&#34;&#34;
        parsed = self.parse(s)

        self.time = ZKDatetimeUtils.time_string_to_datetime(parsed[0])  # type: datetime
        self.pin = parsed[1]   # type: str
        self.card = parsed[2]  # type: str
        self.door = int(parsed[3])  # type: int
        self.event_type = EVENT_TYPES[int(parsed[4])]  # type: DocValue
        self.entry_exit = PassageDirection(int(parsed[5]))  # type: PassageDirection
        self.verify_mode = VerifyMode(int(parsed[6]))  # type: VerifyMode

    @property
    def description(self) -&gt; str:
        msg = &#39;Event[{}]: &#34;{}&#34; at door &#34;{}&#34; for card &#34;{}&#34; -- {}&#39;.format(
            str(self.time), self.event_type.doc, self.door, self.card,
            self.entry_exit.name.capitalize()
        )
        return msg

    @staticmethod
    def parse(event_line: str) -&gt; Sequence[str]:
        &#34;&#34;&#34;Parse raw event string

        Args:
            event_line (str): event string to parse

        Returns:
            Sequence[str]: parsed string parts of event string

        &#34;&#34;&#34;
        event_line = event_line.replace(&#39;\r\n&#39;, &#39;&#39;)

        items = event_line.split(&#39;,&#39;)
        if len(items) != 7:
            raise ValueError(&#34;Event string must have exactly 7 parts: {}&#34;.format(event_line))

        return items

    def __eq__(self, other):
        if isinstance(other, Event):
            return all(getattr(self, attr) == getattr(other, attr) for attr in self.__slots__)
        return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def __str__(self):
        return &#39;Event(&#39; \
               + &#39;, &#39;.join(&#39;{}={}&#39;.format(k, getattr(self, k)) for k in self.__slots__) \
               + &#39;)&#39;

    def __repr__(self):
        return self.__str__()


class EventLog:
    &#34;&#34;&#34;Log of realtime events

    Keep in mind that log is not filled out automatically and
    should be refreshed periodically by hand using `refresh()`
    method. This is because working with ZKAccess has
    request-response nature and cannot up a tunnel which may be
    used to feed events.

    But you can use `poll()` method which awaits new events from
    a device and return them if any.

    Log is implemented at top of deque structure, so accessing by
    index and filtering could be slow.
    &#34;&#34;&#34;
    def __init__(self,
                 sdk: ZKSDK,
                 buffer_size: int,
                 maxlen: Optional[int] = None,
                 only_filters: Optional[dict] = None,
                 _data: Optional[deque] = None):
        self.buffer_size = buffer_size
        self.data = _data if _data is not None else deque(maxlen=maxlen)
        self.only_filters = only_filters or {}
        self._sdk = sdk

    def refresh(self) -&gt; int:
        &#34;&#34;&#34;Make a request to a device for new records and append to the
        end if any.

        Args:

        Returns:
            int: count of records which was added
        &#34;&#34;&#34;
        # ZKAccess always returns single event with code 255
        # on every log query if no other events occured. So, skip it
        new_events = [e for e in self._pull_events() if e.event_type != 255]
        count = 0
        while new_events:
            self.data.extend(new_events)
            count += sum(1 for _ in self._filtered_events(new_events))
            new_events = [e for e in self._pull_events() if e.event_type != 255]

        return count

    def after_time(self, after_time: datetime) -&gt; Iterable[Event]:
        &#34;&#34;&#34;Return events which was occured after given time

        Args:
            after_time (datetime): datetime object to filter (included)

        Returns:
            Iterable[Event]: events
        &#34;&#34;&#34;
        return filter(lambda x: x.time &gt;= after_time, self._filtered_events(self.data))

    def before_time(self, before_time: datetime) -&gt; Iterable[Event]:
        &#34;&#34;&#34;Return events which was occured before given time

        Args:
            before_time (datetime): datetime object to filter (excluded)

        Returns:
            Iterable[Event]: events
        &#34;&#34;&#34;
        return filter(lambda x: x.time &lt; before_time, self._filtered_events(self.data))

    def between_time(self, from_time: datetime, to_time: datetime) -&gt; Iterable[Event]:
        &#34;&#34;&#34;Return events which was occured between two given time moments

        Args:
            from_time (datetime): datetime object to filter (included)
            to_time (datetime): datetime object to filter (excluded)

        Returns:
            Iterable[Event]: events
        &#34;&#34;&#34;
        return filter(lambda x: from_time &lt;= x.time &lt; to_time, self._filtered_events(self.data))

    def poll(self, timeout: float = 60, polling_interval: float = 1) -&gt; List[Event]:
        &#34;&#34;&#34;Wait for new events by making periodically requests to a device.
        If events was appeared then return them. If no event was
        appeared until timeout was expired then return empty iterable.

        Args:
            timeout (float, default=60): timeout in seconds
            polling_interval (float, default=1): interval to make a requests
                in seconds

        Returns:
            Iterable[Event]: events iterable with new events if any
                or empty iterable if timeout has expired

        &#34;&#34;&#34;
        deadline = datetime.now().timestamp() + timeout
        while datetime.now().timestamp() &lt; deadline:
            count = self.refresh()  # Can run up to several seconds depending on network
            if count:
                reversed_events = self._filtered_events(reversed(self.data))
                res = list(itertools.islice(reversed_events, None, count))[::-1]
                return res
            time.sleep(polling_interval)

        return []

    def only(self, **filters) -&gt; &#39;EventLog&#39;:
        &#34;&#34;&#34;Return new EventLog instance with given filters applied.
        Kwargs names must be the same as Event slots.

        Event log returned by this method will contain entries in
        which attribute value is contained in appropriate filter
        (if any).

        Filters passed here will be ANDed during comparison. On
        repeatable call of only, given filters which was also set
        on previous call will be ORed, i.e. their values will be
        concatenated.

        In other words::

            # filtering(entry.a == 2 AND entry.b in (&#39;x&#39;, &#39;y&#39;))
            log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;])
            # filtering(entry.a in (2, 3) AND entry.b in (&#39;x&#39;, &#39;y&#39;, 5) and entry.c == 1)
            log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;]).only(a=3, b=5, c=1)

        Example::

            new_log = log.only(door=1, event_type=221)

        Args:
            **filters (Union[str, Sequence[str]]): filter values or list
                of them

        Returns:
            EventLog: new fitlered EventLog instance

        &#34;&#34;&#34;
        only_filters = self._merge_filters(self.only_filters, filters)
        obj = self.__class__(self._sdk,
                             self.buffer_size,
                             self.data.maxlen,
                             only_filters,
                             _data=self.data)
        return obj

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear log&#34;&#34;&#34;
        self.data.clear()

    @staticmethod
    def _merge_filters(initial: dict, fltr: dict) -&gt; dict:
        &#34;&#34;&#34;Merge two filter dicts, fltr updates initial. Key-values  which
        does not exist in initial will be copied. Value of existent
        keys are combined (values always are lists).

        Args:
          initial (dict): updating initial filter dict
          fltr (dict): filter dict which updates initial

        Returns:
          dict: merged filter dict

        &#34;&#34;&#34;
        seq_types = (tuple, list, set, frozenset)
        res = deepcopy(initial)
        for key, value in fltr.items():
            if not isinstance(value, seq_types):
                value = {value}

            if key in res:
                res[key].update(value)
            else:
                res[key] = set(value)

        return res

    def _filtered_events(self, data: Iterable[Event]) -&gt; Iterable[Event]:
        &#34;&#34;&#34;Apply current filters to given events and return only events
        which meet them

        Args:
          data (Iterable[Event]): unfiltered events

        Returns:
          Iterable[Event]: filtered events

        &#34;&#34;&#34;
        if not self.only_filters:
            yield from data
            return

        for event in data:
            if not self.only_filters:
                yield event
            else:
                all_match = all(getattr(event, field) in fltr
                                for field, fltr in self.only_filters.items())
                if all_match:
                    yield event

    def _pull_events(self) -&gt; Iterable[Event]:
        events = self._sdk.get_rt_log(self.buffer_size)
        return (Event(s) for s in events)

    def __getitem__(self, item: Union[int, slice]) -&gt; Union[Iterable[Event], Event]:
        seq = self._filtered_events(self.data)
        if not isinstance(item, slice):
            try:
                return next(itertools.islice(seq, item, None))
            except StopIteration:
                raise IndexError(&#39;Index is out of range&#39;) from None

        start, stop, step = item.start, item.stop, item.step
        return itertools.islice(seq, start, stop, step)

    def __len__(self) -&gt; int:
        if not self.only_filters:
            return len(self.data)

        return sum(1 for _ in self._filtered_events(self.data))

    def __iter__(self):
        return iter(self._filtered_events(self.data))

    def __str__(self):
        items_str = &#39;, \n&#39;.join(str(x) for x in self)
        return &#39;EventLog[{}](\n{}\n)&#39;.format(len(self), items_str)

    def __repr__(self):
        return self.__str__()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyzkaccess.event.Event"><code class="flex name class">
<span>class <span class="ident">Event</span></span>
<span>(</span><span>s:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>One realtime event occured on the device
Since the device returns event as string we need to parse it to the
structured view. This class does this.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>Event string to be parsed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Event:
    &#34;&#34;&#34;One realtime event occured on the device
    Since the device returns event as string we need to parse it to the
    structured view. This class does this.
    &#34;&#34;&#34;
    __slots__ = (
        &#39;time&#39;,
        &#39;pin&#39;,
        &#39;card&#39;,
        &#39;door&#39;,
        &#39;event_type&#39;,
        &#39;entry_exit&#39;,
        &#39;verify_mode&#39;
    )

    def __init__(self, s: str):
        &#34;&#34;&#34;
        Args:
            s (str): Event string to be parsed.

        &#34;&#34;&#34;
        parsed = self.parse(s)

        self.time = ZKDatetimeUtils.time_string_to_datetime(parsed[0])  # type: datetime
        self.pin = parsed[1]   # type: str
        self.card = parsed[2]  # type: str
        self.door = int(parsed[3])  # type: int
        self.event_type = EVENT_TYPES[int(parsed[4])]  # type: DocValue
        self.entry_exit = PassageDirection(int(parsed[5]))  # type: PassageDirection
        self.verify_mode = VerifyMode(int(parsed[6]))  # type: VerifyMode

    @property
    def description(self) -&gt; str:
        msg = &#39;Event[{}]: &#34;{}&#34; at door &#34;{}&#34; for card &#34;{}&#34; -- {}&#39;.format(
            str(self.time), self.event_type.doc, self.door, self.card,
            self.entry_exit.name.capitalize()
        )
        return msg

    @staticmethod
    def parse(event_line: str) -&gt; Sequence[str]:
        &#34;&#34;&#34;Parse raw event string

        Args:
            event_line (str): event string to parse

        Returns:
            Sequence[str]: parsed string parts of event string

        &#34;&#34;&#34;
        event_line = event_line.replace(&#39;\r\n&#39;, &#39;&#39;)

        items = event_line.split(&#39;,&#39;)
        if len(items) != 7:
            raise ValueError(&#34;Event string must have exactly 7 parts: {}&#34;.format(event_line))

        return items

    def __eq__(self, other):
        if isinstance(other, Event):
            return all(getattr(self, attr) == getattr(other, attr) for attr in self.__slots__)
        return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def __str__(self):
        return &#39;Event(&#39; \
               + &#39;, &#39;.join(&#39;{}={}&#39;.format(k, getattr(self, k)) for k in self.__slots__) \
               + &#39;)&#39;

    def __repr__(self):
        return self.__str__()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyzkaccess.event.Event.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>event_line:Â str) â€‘>Â Sequence[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse raw event string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event_line</code></strong> :&ensp;<code>str</code></dt>
<dd>event string to parse</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Sequence[str]</code></dt>
<dd>parsed string parts of event string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(event_line: str) -&gt; Sequence[str]:
    &#34;&#34;&#34;Parse raw event string

    Args:
        event_line (str): event string to parse

    Returns:
        Sequence[str]: parsed string parts of event string

    &#34;&#34;&#34;
    event_line = event_line.replace(&#39;\r\n&#39;, &#39;&#39;)

    items = event_line.split(&#39;,&#39;)
    if len(items) != 7:
        raise ValueError(&#34;Event string must have exactly 7 parts: {}&#34;.format(event_line))

    return items</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyzkaccess.event.Event.card"><code class="name">var <span class="ident">card</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyzkaccess.event.Event.description"><code class="name">var <span class="ident">description</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    msg = &#39;Event[{}]: &#34;{}&#34; at door &#34;{}&#34; for card &#34;{}&#34; -- {}&#39;.format(
        str(self.time), self.event_type.doc, self.door, self.card,
        self.entry_exit.name.capitalize()
    )
    return msg</code></pre>
</details>
</dd>
<dt id="pyzkaccess.event.Event.door"><code class="name">var <span class="ident">door</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyzkaccess.event.Event.entry_exit"><code class="name">var <span class="ident">entry_exit</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyzkaccess.event.Event.event_type"><code class="name">var <span class="ident">event_type</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyzkaccess.event.Event.pin"><code class="name">var <span class="ident">pin</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyzkaccess.event.Event.time"><code class="name">var <span class="ident">time</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyzkaccess.event.Event.verify_mode"><code class="name">var <span class="ident">verify_mode</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="pyzkaccess.event.EventLog"><code class="flex name class">
<span>class <span class="ident">EventLog</span></span>
<span>(</span><span>sdk:Â <a title="pyzkaccess.sdk.ZKSDK" href="sdk.html#pyzkaccess.sdk.ZKSDK">ZKSDK</a>, buffer_size:Â int, maxlen:Â Optional[int]Â =Â None, only_filters:Â Optional[dict]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Log of realtime events</p>
<p>Keep in mind that log is not filled out automatically and
should be refreshed periodically by hand using <code>refresh()</code>
method. This is because working with ZKAccess has
request-response nature and cannot up a tunnel which may be
used to feed events.</p>
<p>But you can use <code>poll()</code> method which awaits new events from
a device and return them if any.</p>
<p>Log is implemented at top of deque structure, so accessing by
index and filtering could be slow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventLog:
    &#34;&#34;&#34;Log of realtime events

    Keep in mind that log is not filled out automatically and
    should be refreshed periodically by hand using `refresh()`
    method. This is because working with ZKAccess has
    request-response nature and cannot up a tunnel which may be
    used to feed events.

    But you can use `poll()` method which awaits new events from
    a device and return them if any.

    Log is implemented at top of deque structure, so accessing by
    index and filtering could be slow.
    &#34;&#34;&#34;
    def __init__(self,
                 sdk: ZKSDK,
                 buffer_size: int,
                 maxlen: Optional[int] = None,
                 only_filters: Optional[dict] = None,
                 _data: Optional[deque] = None):
        self.buffer_size = buffer_size
        self.data = _data if _data is not None else deque(maxlen=maxlen)
        self.only_filters = only_filters or {}
        self._sdk = sdk

    def refresh(self) -&gt; int:
        &#34;&#34;&#34;Make a request to a device for new records and append to the
        end if any.

        Args:

        Returns:
            int: count of records which was added
        &#34;&#34;&#34;
        # ZKAccess always returns single event with code 255
        # on every log query if no other events occured. So, skip it
        new_events = [e for e in self._pull_events() if e.event_type != 255]
        count = 0
        while new_events:
            self.data.extend(new_events)
            count += sum(1 for _ in self._filtered_events(new_events))
            new_events = [e for e in self._pull_events() if e.event_type != 255]

        return count

    def after_time(self, after_time: datetime) -&gt; Iterable[Event]:
        &#34;&#34;&#34;Return events which was occured after given time

        Args:
            after_time (datetime): datetime object to filter (included)

        Returns:
            Iterable[Event]: events
        &#34;&#34;&#34;
        return filter(lambda x: x.time &gt;= after_time, self._filtered_events(self.data))

    def before_time(self, before_time: datetime) -&gt; Iterable[Event]:
        &#34;&#34;&#34;Return events which was occured before given time

        Args:
            before_time (datetime): datetime object to filter (excluded)

        Returns:
            Iterable[Event]: events
        &#34;&#34;&#34;
        return filter(lambda x: x.time &lt; before_time, self._filtered_events(self.data))

    def between_time(self, from_time: datetime, to_time: datetime) -&gt; Iterable[Event]:
        &#34;&#34;&#34;Return events which was occured between two given time moments

        Args:
            from_time (datetime): datetime object to filter (included)
            to_time (datetime): datetime object to filter (excluded)

        Returns:
            Iterable[Event]: events
        &#34;&#34;&#34;
        return filter(lambda x: from_time &lt;= x.time &lt; to_time, self._filtered_events(self.data))

    def poll(self, timeout: float = 60, polling_interval: float = 1) -&gt; List[Event]:
        &#34;&#34;&#34;Wait for new events by making periodically requests to a device.
        If events was appeared then return them. If no event was
        appeared until timeout was expired then return empty iterable.

        Args:
            timeout (float, default=60): timeout in seconds
            polling_interval (float, default=1): interval to make a requests
                in seconds

        Returns:
            Iterable[Event]: events iterable with new events if any
                or empty iterable if timeout has expired

        &#34;&#34;&#34;
        deadline = datetime.now().timestamp() + timeout
        while datetime.now().timestamp() &lt; deadline:
            count = self.refresh()  # Can run up to several seconds depending on network
            if count:
                reversed_events = self._filtered_events(reversed(self.data))
                res = list(itertools.islice(reversed_events, None, count))[::-1]
                return res
            time.sleep(polling_interval)

        return []

    def only(self, **filters) -&gt; &#39;EventLog&#39;:
        &#34;&#34;&#34;Return new EventLog instance with given filters applied.
        Kwargs names must be the same as Event slots.

        Event log returned by this method will contain entries in
        which attribute value is contained in appropriate filter
        (if any).

        Filters passed here will be ANDed during comparison. On
        repeatable call of only, given filters which was also set
        on previous call will be ORed, i.e. their values will be
        concatenated.

        In other words::

            # filtering(entry.a == 2 AND entry.b in (&#39;x&#39;, &#39;y&#39;))
            log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;])
            # filtering(entry.a in (2, 3) AND entry.b in (&#39;x&#39;, &#39;y&#39;, 5) and entry.c == 1)
            log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;]).only(a=3, b=5, c=1)

        Example::

            new_log = log.only(door=1, event_type=221)

        Args:
            **filters (Union[str, Sequence[str]]): filter values or list
                of them

        Returns:
            EventLog: new fitlered EventLog instance

        &#34;&#34;&#34;
        only_filters = self._merge_filters(self.only_filters, filters)
        obj = self.__class__(self._sdk,
                             self.buffer_size,
                             self.data.maxlen,
                             only_filters,
                             _data=self.data)
        return obj

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear log&#34;&#34;&#34;
        self.data.clear()

    @staticmethod
    def _merge_filters(initial: dict, fltr: dict) -&gt; dict:
        &#34;&#34;&#34;Merge two filter dicts, fltr updates initial. Key-values  which
        does not exist in initial will be copied. Value of existent
        keys are combined (values always are lists).

        Args:
          initial (dict): updating initial filter dict
          fltr (dict): filter dict which updates initial

        Returns:
          dict: merged filter dict

        &#34;&#34;&#34;
        seq_types = (tuple, list, set, frozenset)
        res = deepcopy(initial)
        for key, value in fltr.items():
            if not isinstance(value, seq_types):
                value = {value}

            if key in res:
                res[key].update(value)
            else:
                res[key] = set(value)

        return res

    def _filtered_events(self, data: Iterable[Event]) -&gt; Iterable[Event]:
        &#34;&#34;&#34;Apply current filters to given events and return only events
        which meet them

        Args:
          data (Iterable[Event]): unfiltered events

        Returns:
          Iterable[Event]: filtered events

        &#34;&#34;&#34;
        if not self.only_filters:
            yield from data
            return

        for event in data:
            if not self.only_filters:
                yield event
            else:
                all_match = all(getattr(event, field) in fltr
                                for field, fltr in self.only_filters.items())
                if all_match:
                    yield event

    def _pull_events(self) -&gt; Iterable[Event]:
        events = self._sdk.get_rt_log(self.buffer_size)
        return (Event(s) for s in events)

    def __getitem__(self, item: Union[int, slice]) -&gt; Union[Iterable[Event], Event]:
        seq = self._filtered_events(self.data)
        if not isinstance(item, slice):
            try:
                return next(itertools.islice(seq, item, None))
            except StopIteration:
                raise IndexError(&#39;Index is out of range&#39;) from None

        start, stop, step = item.start, item.stop, item.step
        return itertools.islice(seq, start, stop, step)

    def __len__(self) -&gt; int:
        if not self.only_filters:
            return len(self.data)

        return sum(1 for _ in self._filtered_events(self.data))

    def __iter__(self):
        return iter(self._filtered_events(self.data))

    def __str__(self):
        items_str = &#39;, \n&#39;.join(str(x) for x in self)
        return &#39;EventLog[{}](\n{}\n)&#39;.format(len(self), items_str)

    def __repr__(self):
        return self.__str__()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyzkaccess.event.EventLog.after_time"><code class="name flex">
<span>def <span class="ident">after_time</span></span>(<span>self, after_time:Â datetime.datetime) â€‘>Â Iterable[<a title="pyzkaccess.event.Event" href="#pyzkaccess.event.Event">Event</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return events which was occured after given time</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>after_time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>datetime object to filter (included)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterable[<a title="pyzkaccess.event.Event" href="#pyzkaccess.event.Event">Event</a>]</code></dt>
<dd>events</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def after_time(self, after_time: datetime) -&gt; Iterable[Event]:
    &#34;&#34;&#34;Return events which was occured after given time

    Args:
        after_time (datetime): datetime object to filter (included)

    Returns:
        Iterable[Event]: events
    &#34;&#34;&#34;
    return filter(lambda x: x.time &gt;= after_time, self._filtered_events(self.data))</code></pre>
</details>
</dd>
<dt id="pyzkaccess.event.EventLog.before_time"><code class="name flex">
<span>def <span class="ident">before_time</span></span>(<span>self, before_time:Â datetime.datetime) â€‘>Â Iterable[<a title="pyzkaccess.event.Event" href="#pyzkaccess.event.Event">Event</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return events which was occured before given time</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>before_time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>datetime object to filter (excluded)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterable[<a title="pyzkaccess.event.Event" href="#pyzkaccess.event.Event">Event</a>]</code></dt>
<dd>events</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def before_time(self, before_time: datetime) -&gt; Iterable[Event]:
    &#34;&#34;&#34;Return events which was occured before given time

    Args:
        before_time (datetime): datetime object to filter (excluded)

    Returns:
        Iterable[Event]: events
    &#34;&#34;&#34;
    return filter(lambda x: x.time &lt; before_time, self._filtered_events(self.data))</code></pre>
</details>
</dd>
<dt id="pyzkaccess.event.EventLog.between_time"><code class="name flex">
<span>def <span class="ident">between_time</span></span>(<span>self, from_time:Â datetime.datetime, to_time:Â datetime.datetime) â€‘>Â Iterable[<a title="pyzkaccess.event.Event" href="#pyzkaccess.event.Event">Event</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return events which was occured between two given time moments</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>from_time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>datetime object to filter (included)</dd>
<dt><strong><code>to_time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>datetime object to filter (excluded)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterable[<a title="pyzkaccess.event.Event" href="#pyzkaccess.event.Event">Event</a>]</code></dt>
<dd>events</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def between_time(self, from_time: datetime, to_time: datetime) -&gt; Iterable[Event]:
    &#34;&#34;&#34;Return events which was occured between two given time moments

    Args:
        from_time (datetime): datetime object to filter (included)
        to_time (datetime): datetime object to filter (excluded)

    Returns:
        Iterable[Event]: events
    &#34;&#34;&#34;
    return filter(lambda x: from_time &lt;= x.time &lt; to_time, self._filtered_events(self.data))</code></pre>
</details>
</dd>
<dt id="pyzkaccess.event.EventLog.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear log</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear log&#34;&#34;&#34;
    self.data.clear()</code></pre>
</details>
</dd>
<dt id="pyzkaccess.event.EventLog.only"><code class="name flex">
<span>def <span class="ident">only</span></span>(<span>self, **filters) â€‘>Â <a title="pyzkaccess.event.EventLog" href="#pyzkaccess.event.EventLog">EventLog</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return new EventLog instance with given filters applied.
Kwargs names must be the same as Event slots.</p>
<p>Event log returned by this method will contain entries in
which attribute value is contained in appropriate filter
(if any).</p>
<p>Filters passed here will be ANDed during comparison. On
repeatable call of only, given filters which was also set
on previous call will be ORed, i.e. their values will be
concatenated.</p>
<p>In other words::</p>
<pre><code># filtering(entry.a == 2 AND entry.b in ('x', 'y'))
log.only(a=2, b=['x', 'y'])
# filtering(entry.a in (2, 3) AND entry.b in ('x', 'y', 5) and entry.c == 1)
log.only(a=2, b=['x', 'y']).only(a=3, b=5, c=1)
</code></pre>
<p>Example::</p>
<pre><code>new_log = log.only(door=1, event_type=221)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**filters</code></strong> :&ensp;<code>Union[str, Sequence[str]]</code></dt>
<dd>filter values or list
of them</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pyzkaccess.event.EventLog" href="#pyzkaccess.event.EventLog">EventLog</a></code></dt>
<dd>new fitlered EventLog instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def only(self, **filters) -&gt; &#39;EventLog&#39;:
    &#34;&#34;&#34;Return new EventLog instance with given filters applied.
    Kwargs names must be the same as Event slots.

    Event log returned by this method will contain entries in
    which attribute value is contained in appropriate filter
    (if any).

    Filters passed here will be ANDed during comparison. On
    repeatable call of only, given filters which was also set
    on previous call will be ORed, i.e. their values will be
    concatenated.

    In other words::

        # filtering(entry.a == 2 AND entry.b in (&#39;x&#39;, &#39;y&#39;))
        log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;])
        # filtering(entry.a in (2, 3) AND entry.b in (&#39;x&#39;, &#39;y&#39;, 5) and entry.c == 1)
        log.only(a=2, b=[&#39;x&#39;, &#39;y&#39;]).only(a=3, b=5, c=1)

    Example::

        new_log = log.only(door=1, event_type=221)

    Args:
        **filters (Union[str, Sequence[str]]): filter values or list
            of them

    Returns:
        EventLog: new fitlered EventLog instance

    &#34;&#34;&#34;
    only_filters = self._merge_filters(self.only_filters, filters)
    obj = self.__class__(self._sdk,
                         self.buffer_size,
                         self.data.maxlen,
                         only_filters,
                         _data=self.data)
    return obj</code></pre>
</details>
</dd>
<dt id="pyzkaccess.event.EventLog.poll"><code class="name flex">
<span>def <span class="ident">poll</span></span>(<span>self, timeout:Â floatÂ =Â 60, polling_interval:Â floatÂ =Â 1) â€‘>Â List[<a title="pyzkaccess.event.Event" href="#pyzkaccess.event.Event">Event</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for new events by making periodically requests to a device.
If events was appeared then return them. If no event was
appeared until timeout was expired then return empty iterable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code>, default=<code>60</code></dt>
<dd>timeout in seconds</dd>
<dt><strong><code>polling_interval</code></strong> :&ensp;<code>float</code>, default=<code>1</code></dt>
<dd>interval to make a requests
in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterable[<a title="pyzkaccess.event.Event" href="#pyzkaccess.event.Event">Event</a>]</code></dt>
<dd>events iterable with new events if any
or empty iterable if timeout has expired</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poll(self, timeout: float = 60, polling_interval: float = 1) -&gt; List[Event]:
    &#34;&#34;&#34;Wait for new events by making periodically requests to a device.
    If events was appeared then return them. If no event was
    appeared until timeout was expired then return empty iterable.

    Args:
        timeout (float, default=60): timeout in seconds
        polling_interval (float, default=1): interval to make a requests
            in seconds

    Returns:
        Iterable[Event]: events iterable with new events if any
            or empty iterable if timeout has expired

    &#34;&#34;&#34;
    deadline = datetime.now().timestamp() + timeout
    while datetime.now().timestamp() &lt; deadline:
        count = self.refresh()  # Can run up to several seconds depending on network
        if count:
            reversed_events = self._filtered_events(reversed(self.data))
            res = list(itertools.islice(reversed_events, None, count))[::-1]
            return res
        time.sleep(polling_interval)

    return []</code></pre>
</details>
</dd>
<dt id="pyzkaccess.event.EventLog.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Make a request to a device for new records and append to the
end if any.</p>
<p>Args:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>count of records which was added</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self) -&gt; int:
    &#34;&#34;&#34;Make a request to a device for new records and append to the
    end if any.

    Args:

    Returns:
        int: count of records which was added
    &#34;&#34;&#34;
    # ZKAccess always returns single event with code 255
    # on every log query if no other events occured. So, skip it
    new_events = [e for e in self._pull_events() if e.event_type != 255]
    count = 0
    while new_events:
        self.data.extend(new_events)
        count += sum(1 for _ in self._filtered_events(new_events))
        new_events = [e for e in self._pull_events() if e.event_type != 255]

    return count</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyzkaccess" href="index.html">pyzkaccess</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyzkaccess.event.Event" href="#pyzkaccess.event.Event">Event</a></code></h4>
<ul class="two-column">
<li><code><a title="pyzkaccess.event.Event.card" href="#pyzkaccess.event.Event.card">card</a></code></li>
<li><code><a title="pyzkaccess.event.Event.description" href="#pyzkaccess.event.Event.description">description</a></code></li>
<li><code><a title="pyzkaccess.event.Event.door" href="#pyzkaccess.event.Event.door">door</a></code></li>
<li><code><a title="pyzkaccess.event.Event.entry_exit" href="#pyzkaccess.event.Event.entry_exit">entry_exit</a></code></li>
<li><code><a title="pyzkaccess.event.Event.event_type" href="#pyzkaccess.event.Event.event_type">event_type</a></code></li>
<li><code><a title="pyzkaccess.event.Event.parse" href="#pyzkaccess.event.Event.parse">parse</a></code></li>
<li><code><a title="pyzkaccess.event.Event.pin" href="#pyzkaccess.event.Event.pin">pin</a></code></li>
<li><code><a title="pyzkaccess.event.Event.time" href="#pyzkaccess.event.Event.time">time</a></code></li>
<li><code><a title="pyzkaccess.event.Event.verify_mode" href="#pyzkaccess.event.Event.verify_mode">verify_mode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyzkaccess.event.EventLog" href="#pyzkaccess.event.EventLog">EventLog</a></code></h4>
<ul class="two-column">
<li><code><a title="pyzkaccess.event.EventLog.after_time" href="#pyzkaccess.event.EventLog.after_time">after_time</a></code></li>
<li><code><a title="pyzkaccess.event.EventLog.before_time" href="#pyzkaccess.event.EventLog.before_time">before_time</a></code></li>
<li><code><a title="pyzkaccess.event.EventLog.between_time" href="#pyzkaccess.event.EventLog.between_time">between_time</a></code></li>
<li><code><a title="pyzkaccess.event.EventLog.clear" href="#pyzkaccess.event.EventLog.clear">clear</a></code></li>
<li><code><a title="pyzkaccess.event.EventLog.only" href="#pyzkaccess.event.EventLog.only">only</a></code></li>
<li><code><a title="pyzkaccess.event.EventLog.poll" href="#pyzkaccess.event.EventLog.poll">poll</a></code></li>
<li><code><a title="pyzkaccess.event.EventLog.refresh" href="#pyzkaccess.event.EventLog.refresh">refresh</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>