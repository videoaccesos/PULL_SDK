<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyzkaccess.common API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyzkaccess.common</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__all__ = [
    &#39;UserTuple&#39;,
    &#39;DocValue&#39;,
    &#39;DocDict&#39;,
    &#39;ZKDatetimeUtils&#39;
]
from copy import copy, deepcopy
from datetime import datetime, time, date
from typing import Sequence, Union, Iterable, Tuple, Optional

from wrapt import ObjectProxy
from wrapt.wrappers import _ObjectProxyMetaType  # noqa


class UserTuple:
    &#34;&#34;&#34;Immutable version of `collections.UserList` from the stdlib&#34;&#34;&#34;
    def __init__(self, initlist: Union[Sequence, Iterable, &#39;UserTuple&#39;] = None):
        self.data = tuple()
        if initlist is not None:
            # XXX should this accept an arbitrary sequence?
            if isinstance(initlist, tuple):
                self.data = initlist
            elif isinstance(initlist, UserTuple):
                self.data = copy(initlist.data)
            else:
                self.data = tuple(initlist)

    def __repr__(self): return repr(self.data)
    def __lt__(self, other): return self.data &lt;  self.__cast(other)  # noqa
    def __le__(self, other): return self.data &lt;= self.__cast(other)
    def __eq__(self, other): return self.data == self.__cast(other)
    def __gt__(self, other): return self.data &gt;  self.__cast(other)  # noqa
    def __ge__(self, other): return self.data &gt;= self.__cast(other)

    def __cast(self, other):
        return other.data if isinstance(other, UserTuple) else other

    def __contains__(self, item): return item in self.data
    def __len__(self): return len(self.data)

    def __getitem__(self, i):
        if isinstance(i, slice):
            return self.__class__(self.data[i])
        else:
            return self.data[i]

    def __add__(self, other):
        if isinstance(other, UserTuple):
            return self.__class__(self.data + other.data)
        elif isinstance(other, type(self.data)):
            return self.__class__(self.data + other)
        return self.__class__(self.data + list(other))

    def __radd__(self, other):
        if isinstance(other, UserTuple):
            return self.__class__(other.data + self.data)
        elif isinstance(other, type(self.data)):
            return self.__class__(other + self.data)
        return self.__class__(list(other) + self.data)

    def __iadd__(self, other):
        if isinstance(other, UserTuple):
            self.data += other.data
        elif isinstance(other, type(self.data)):
            self.data += other
        else:
            self.data += list(other)
        return self

    def __mul__(self, n):
        return self.__class__(self.data*n)

    __rmul__ = __mul__

    def __imul__(self, n):
        self.data *= n
        return self

    def __hash__(self):
        return hash(self.data)

    def __copy__(self):
        inst = self.__class__.__new__(self.__class__)
        inst.__dict__.update(self.__dict__)
        # Create a copy and avoid triggering descriptors
        inst.__dict__[&#34;data&#34;] = self.__dict__[&#34;data&#34;][:]
        return inst

    def copy(self): return self.__class__(self)
    def count(self, item): return self.data.count(item)
    def index(self, item, *args): return self.data.index(item, *args)


class DocValueMeta(_ObjectProxyMetaType):
    def __new__(cls, name, bases, attrs):
        # Hack: override class creation for proxy object since
        # ObjectProxy metaclass doesn&#39;t allow easily redefine __doc__
        def get_doc(self):
            return self._self_doc if self._self_doc else self.__wrapped__.__doc__

        doc_prop = property(get_doc, None, None)

        new_class = super().__new__(cls, name, bases, attrs)
        type.__setattr__(new_class, &#39;__doc__&#39;, doc_prop)
        type.__setattr__(new_class, &#39;__module__&#39;, &#39;&#39;)
        return new_class


class DocValue(ObjectProxy, metaclass=DocValueMeta):
    &#34;&#34;&#34;Value of type with custom __doc__ attribute. The main aim is to
    annotate a value of any type including built-in ones
    &#34;&#34;&#34;
    def __init__(self, value: Union[str, int], doc: str):
        &#34;&#34;&#34;
        Args:
            value (Union[str, int]): value which was exposed by this
                object
            doc (str): documentation string which will be put to __doc__
        &#34;&#34;&#34;
        super().__init__(value)
        if not isinstance(value, (str, int)):
            raise TypeError(&#39;Init value type must be int or str&#39;)

        self._self_value = value
        self._self_doc = doc

    def __repr__(self):
        return self.__wrapped__.__repr__()

    @property
    def value(self):
        &#34;&#34;&#34;Exposed value&#34;&#34;&#34;
        return self._self_value

    @property
    def doc(self):
        &#34;&#34;&#34;Documentation of a value&#34;&#34;&#34;
        return self._self_doc

    def __copy__(self):
        obj = DocValue(copy(self._self_value), copy(self._self_doc))
        return obj

    def __deepcopy__(self, memodict=None):
        obj = DocValue(deepcopy(self._self_value), deepcopy(self._self_doc))
        return obj


class DocDict(dict):
    &#34;&#34;&#34;DocDict is dictionary, where values are annotated versions
    of keys.

    As initial value DocDict accepts a dictionary where dict key is
    an exposed value and dict value is docstring.

        &gt;&gt;&gt; d = DocDict({1: &#39;Docstring 1&#39;, &#39;2&#39;: &#39;Docstring 2&#39;})
        &gt;&gt;&gt; print(repr(d[1]), repr(d[&#39;2&#39;]))
        1 &#39;2&#39;
        &gt;&gt;&gt; print(type(d[1]), type(d[&#39;2&#39;]))
        &lt;class &#39;DocValue&#39;&gt; &lt;class &#39;DocValue&#39;&gt;
        &gt;&gt;&gt; print(d[1] == 1)
        True
        &gt;&gt;&gt; print(d[&#39;2&#39;] == &#39;2&#39;)
        True
        &gt;&gt;&gt; print(isinstance(d[1], int), isinstance(d[&#39;2&#39;], str))
        True True
        &gt;&gt;&gt; print(d[1].__doc__, &#39;,&#39;, d[&#39;2&#39;].__doc__)
        Docstring 1 , Docstring 2
    &#34;&#34;&#34;
    def __init__(self, initdict: dict):
        super().__init__({k: DocValue(k, v) for k, v in initdict.items()})


class ZKDatetimeUtils:
    &#34;&#34;&#34;Utility functions to work with date/time types in ZKAccess SDK.

    ZK devices has various ways to work with dates and time. In
    order to make working with dates more convenient in user&#39;s code,
    these functions converts standard python objects from datetime
    module into a specific format.
    &#34;&#34;&#34;
    @staticmethod
    def zkctime_to_datetime(zkctime: Union[str, int]) -&gt; datetime:
        &#34;&#34;&#34;Convert ZK-specific ctime integer value to a datetime object.

        Simply put this ctime is a count of seconds starting from
        `2000-01-01 00:00:00` without considering leap years/seconds
        and days count in months (always 31 day)

        Args:
            zkctime (Union[str, int]): ZK ctime integer or string value

        Returns:
            datetime: converted datetime

        &#34;&#34;&#34;
        if isinstance(zkctime, str):
            zkctime = int(zkctime)

        if zkctime &lt; 0:
            raise ValueError(&#39;Value must be a positive number&#39;)

        return datetime(
            year=zkctime // 32140800 + 2000,
            month=(zkctime // 2678400) % 12 + 1,
            day=(zkctime // 86400) % 31 + 1,
            hour=(zkctime // 3600) % 24,
            minute=(zkctime // 60) % 60,
            second=zkctime % 60
        )

    @staticmethod
    def datetime_to_zkctime(dt: datetime) -&gt; int:
        &#34;&#34;&#34;Converts datetime object to a ZK-specific ctime value.
        Such type can be found in device parameters and data tables.

        Simply put this ctime is a count of seconds starting from
        `2000-01-01 00:00:00` without considering leap years/seconds
        and days count in months (always 31 day)

        Args:
            dt (datetime): datetime object to convert

        Returns:
            int: ZK ctime integer value

        &#34;&#34;&#34;
        if dt.year &lt; 2000:
            raise ValueError(&#39;Cannot get zkctime from a date earlier than a midnight of 2000-01-01&#39;)

        return sum((
            sum((
                (dt.year - 2000) * 12 * 31,
                (dt.month - 1) * 31,
                (dt.day - 1)
            )) * 24 * 60 * 60,
            dt.hour * 60 * 60,
            dt.minute * 60,
            dt.second
        ))

    @staticmethod
    def time_string_to_datetime(dt_string: str) -&gt; datetime:
        &#34;&#34;&#34;Parses datetime string and return datetime object. Such value
        is used in events list. Datetime string has ISO date format.

        Args:
            dt_string (str): datetime string, e.g. `2021-04-15 21:21:00`

        Returns:
            datetime: converted datetime object

        &#34;&#34;&#34;
        return datetime.strptime(dt_string, &#39;%Y-%m-%d %H:%M:%S&#39;)

    @staticmethod
    def zktimerange_to_times(zktr: Union[str, int]) -&gt; Tuple[time, time]:
        &#34;&#34;&#34;Decode 4-byte time range into time objects couple.
        Such approach is used in Timezone table.

        Simply put, the higher 2 bytes are &#34;from&#34; part of range,
        the lower 2 bytes are &#34;to&#34; part. Time part is encoded as
        `(hour * 100) + minutes`.

        Args:
            zktr (Union[str, int]): encoded time range as integer or
                as number in string

        Returns:
            Tuple[time, time]: 2-tuple of from-tp time objects
                (without timezone)

        &#34;&#34;&#34;
        if isinstance(zktr, str):
            zktr = int(zktr)

        if zktr &lt; 0:
            raise ValueError(&#39;time range cannot be a negative number&#39;)

        to_num = zktr &amp; 0xffff
        from_num = (zktr &gt;&gt; 16) &amp; 0xffff
        from_t = time(hour=from_num // 100, minute=from_num % 100)
        to_t = time(hour=to_num // 100, minute=to_num % 100)

        return from_t, to_t

    @staticmethod
    def times_to_zktimerange(from_t: Union[datetime, time], to_t: Union[datetime, time]) -&gt; int:
        &#34;&#34;&#34;Encode time range in time/datetime objects into one 4-byte
        integer. Such approach is used in Timezone table.

        Simply put, the higher 2 bytes are &#34;from&#34; part of range,
        the lower 2 bytes are &#34;to&#34; part. Time part is encoded as
        `(hour * 100) + minutes`.

        Args:
            from_t (Union[datetime, time]): time/datetime &#34;from&#34; part
                of time range
            to_t (Union[datetime, time]): time/datetime &#34;to&#34; part
                of time range

        Returns:
            int: encoded 4-byte integer

        &#34;&#34;&#34;
        return ((from_t.hour * 100 + from_t.minute) &lt;&lt; 16) + (to_t.hour * 100 + to_t.minute)

    @staticmethod
    def zkdate_to_date(zkd: str) -&gt; Optional[date]:
        &#34;&#34;&#34;Parse date string and return date object. Such format is
        used in User table.

        Date format is simple: &#39;YYYYMMDD&#39;

        Args:
            zkd (str): date string

        Returns:
            Optional[date]: parsed date object

        &#34;&#34;&#34;
        # Device can return &#39;0&#39; string for date fields
        if zkd == &#39;0&#39;:
            return None

        return datetime.strptime(zkd, &#39;%Y%m%d&#39;).date()

    @staticmethod
    def date_to_zkdate(d: Union[date, datetime]) -&gt; str:
        &#34;&#34;&#34;Make a date string from a given date/datetime object. Such
        format is used in User table.

        Date format is simple: &#39;YYYYMMDD&#39;

        Args:
            d (Union[date, datetime]): date/datetime object

        Returns:
            str: date string

        &#34;&#34;&#34;
        return d.strftime(&#39;%Y%m%d&#39;)

    @staticmethod
    def zktimemoment_to_datetime(zktm: Union[str, int]) -&gt; Optional[datetime]:
        &#34;&#34;&#34;Decode 4-byte time annual time moment to a datetime with
        year and timezone ignored. Such approach is used in
        DaylightSavingTime, StandardTime parameters.

        Simply put, each byte represents time piece in order: month,
        day, hour, minute

        Args:
            zktm: (Union[str, int]): encoded annual time moment as
                integer or as number in string

        Returns:
            datetime: decoded datetime object
        &#34;&#34;&#34;
        if zktm in (&#39;0&#39;, 0):
            return None

        if isinstance(zktm, str):
            zktm = int(zktm)

        return datetime(
            year=1970,
            month=(zktm &gt;&gt; 24) &amp; 0xff,
            day=(zktm &gt;&gt; 16) &amp; 0xff,
            hour=(zktm &gt;&gt; 8) &amp; 0xff,
            minute=zktm &amp; 0xff
        )

    @staticmethod
    def datetime_to_zktimemoment(dt: datetime) -&gt; int:
        &#34;&#34;&#34;Encode time moment in datetime object into a 4-byte integer
        used in a device as annual time moment representation. Year and
        timezone will be ignored. Such approach is used in
        DaylightSavingTime, StandardTime parameters.

        Args:
            dt: datetime object

        Returns:
            int: encoded annual time moment
        &#34;&#34;&#34;
        return int((dt.month &lt;&lt; 24) | (dt.day &lt;&lt; 16) | (dt.hour &lt;&lt; 8) | dt.minute)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyzkaccess.common.DocDict"><code class="flex name class">
<span>class <span class="ident">DocDict</span></span>
<span>(</span><span>initdict: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>DocDict is dictionary, where values are annotated versions
of keys.</p>
<p>As initial value DocDict accepts a dictionary where dict key is
an exposed value and dict value is docstring.</p>
<pre><code>&gt;&gt;&gt; d = DocDict({1: 'Docstring 1', '2': 'Docstring 2'})
&gt;&gt;&gt; print(repr(d[1]), repr(d['2']))
1 '2'
&gt;&gt;&gt; print(type(d[1]), type(d['2']))
&lt;class 'DocValue'&gt; &lt;class 'DocValue'&gt;
&gt;&gt;&gt; print(d[1] == 1)
True
&gt;&gt;&gt; print(d['2'] == '2')
True
&gt;&gt;&gt; print(isinstance(d[1], int), isinstance(d['2'], str))
True True
&gt;&gt;&gt; print(d[1].__doc__, ',', d['2'].__doc__)
Docstring 1 , Docstring 2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DocDict(dict):
    &#34;&#34;&#34;DocDict is dictionary, where values are annotated versions
    of keys.

    As initial value DocDict accepts a dictionary where dict key is
    an exposed value and dict value is docstring.

        &gt;&gt;&gt; d = DocDict({1: &#39;Docstring 1&#39;, &#39;2&#39;: &#39;Docstring 2&#39;})
        &gt;&gt;&gt; print(repr(d[1]), repr(d[&#39;2&#39;]))
        1 &#39;2&#39;
        &gt;&gt;&gt; print(type(d[1]), type(d[&#39;2&#39;]))
        &lt;class &#39;DocValue&#39;&gt; &lt;class &#39;DocValue&#39;&gt;
        &gt;&gt;&gt; print(d[1] == 1)
        True
        &gt;&gt;&gt; print(d[&#39;2&#39;] == &#39;2&#39;)
        True
        &gt;&gt;&gt; print(isinstance(d[1], int), isinstance(d[&#39;2&#39;], str))
        True True
        &gt;&gt;&gt; print(d[1].__doc__, &#39;,&#39;, d[&#39;2&#39;].__doc__)
        Docstring 1 , Docstring 2
    &#34;&#34;&#34;
    def __init__(self, initdict: dict):
        super().__init__({k: DocValue(k, v) for k, v in initdict.items()})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
<dt id="pyzkaccess.common.UserTuple"><code class="flex name class">
<span>class <span class="ident">UserTuple</span></span>
<span>(</span><span>initlist: Union[Sequence, Iterable, ForwardRef('<a title="pyzkaccess.common.UserTuple" href="#pyzkaccess.common.UserTuple">UserTuple</a>')] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Immutable version of <code>collections.UserList</code> from the stdlib</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserTuple:
    &#34;&#34;&#34;Immutable version of `collections.UserList` from the stdlib&#34;&#34;&#34;
    def __init__(self, initlist: Union[Sequence, Iterable, &#39;UserTuple&#39;] = None):
        self.data = tuple()
        if initlist is not None:
            # XXX should this accept an arbitrary sequence?
            if isinstance(initlist, tuple):
                self.data = initlist
            elif isinstance(initlist, UserTuple):
                self.data = copy(initlist.data)
            else:
                self.data = tuple(initlist)

    def __repr__(self): return repr(self.data)
    def __lt__(self, other): return self.data &lt;  self.__cast(other)  # noqa
    def __le__(self, other): return self.data &lt;= self.__cast(other)
    def __eq__(self, other): return self.data == self.__cast(other)
    def __gt__(self, other): return self.data &gt;  self.__cast(other)  # noqa
    def __ge__(self, other): return self.data &gt;= self.__cast(other)

    def __cast(self, other):
        return other.data if isinstance(other, UserTuple) else other

    def __contains__(self, item): return item in self.data
    def __len__(self): return len(self.data)

    def __getitem__(self, i):
        if isinstance(i, slice):
            return self.__class__(self.data[i])
        else:
            return self.data[i]

    def __add__(self, other):
        if isinstance(other, UserTuple):
            return self.__class__(self.data + other.data)
        elif isinstance(other, type(self.data)):
            return self.__class__(self.data + other)
        return self.__class__(self.data + list(other))

    def __radd__(self, other):
        if isinstance(other, UserTuple):
            return self.__class__(other.data + self.data)
        elif isinstance(other, type(self.data)):
            return self.__class__(other + self.data)
        return self.__class__(list(other) + self.data)

    def __iadd__(self, other):
        if isinstance(other, UserTuple):
            self.data += other.data
        elif isinstance(other, type(self.data)):
            self.data += other
        else:
            self.data += list(other)
        return self

    def __mul__(self, n):
        return self.__class__(self.data*n)

    __rmul__ = __mul__

    def __imul__(self, n):
        self.data *= n
        return self

    def __hash__(self):
        return hash(self.data)

    def __copy__(self):
        inst = self.__class__.__new__(self.__class__)
        inst.__dict__.update(self.__dict__)
        # Create a copy and avoid triggering descriptors
        inst.__dict__[&#34;data&#34;] = self.__dict__[&#34;data&#34;][:]
        return inst

    def copy(self): return self.__class__(self)
    def count(self, item): return self.data.count(item)
    def index(self, item, *args): return self.data.index(item, *args)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyzkaccess.aux_input.AuxInputList" href="aux_input.html#pyzkaccess.aux_input.AuxInputList">AuxInputList</a></li>
<li><a title="pyzkaccess.door.DoorList" href="door.html#pyzkaccess.door.DoorList">DoorList</a></li>
<li><a title="pyzkaccess.reader.ReaderList" href="reader.html#pyzkaccess.reader.ReaderList">ReaderList</a></li>
<li><a title="pyzkaccess.relay.RelayList" href="relay.html#pyzkaccess.relay.RelayList">RelayList</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyzkaccess.common.UserTuple.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self): return self.__class__(self)</code></pre>
</details>
</dd>
<dt id="pyzkaccess.common.UserTuple.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self, item): return self.data.count(item)</code></pre>
</details>
</dd>
<dt id="pyzkaccess.common.UserTuple.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>self, item, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(self, item, *args): return self.data.index(item, *args)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyzkaccess.common.ZKDatetimeUtils"><code class="flex name class">
<span>class <span class="ident">ZKDatetimeUtils</span></span>
</code></dt>
<dd>
<div class="desc"><p>Utility functions to work with date/time types in ZKAccess SDK.</p>
<p>ZK devices has various ways to work with dates and time. In
order to make working with dates more convenient in user's code,
these functions converts standard python objects from datetime
module into a specific format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZKDatetimeUtils:
    &#34;&#34;&#34;Utility functions to work with date/time types in ZKAccess SDK.

    ZK devices has various ways to work with dates and time. In
    order to make working with dates more convenient in user&#39;s code,
    these functions converts standard python objects from datetime
    module into a specific format.
    &#34;&#34;&#34;
    @staticmethod
    def zkctime_to_datetime(zkctime: Union[str, int]) -&gt; datetime:
        &#34;&#34;&#34;Convert ZK-specific ctime integer value to a datetime object.

        Simply put this ctime is a count of seconds starting from
        `2000-01-01 00:00:00` without considering leap years/seconds
        and days count in months (always 31 day)

        Args:
            zkctime (Union[str, int]): ZK ctime integer or string value

        Returns:
            datetime: converted datetime

        &#34;&#34;&#34;
        if isinstance(zkctime, str):
            zkctime = int(zkctime)

        if zkctime &lt; 0:
            raise ValueError(&#39;Value must be a positive number&#39;)

        return datetime(
            year=zkctime // 32140800 + 2000,
            month=(zkctime // 2678400) % 12 + 1,
            day=(zkctime // 86400) % 31 + 1,
            hour=(zkctime // 3600) % 24,
            minute=(zkctime // 60) % 60,
            second=zkctime % 60
        )

    @staticmethod
    def datetime_to_zkctime(dt: datetime) -&gt; int:
        &#34;&#34;&#34;Converts datetime object to a ZK-specific ctime value.
        Such type can be found in device parameters and data tables.

        Simply put this ctime is a count of seconds starting from
        `2000-01-01 00:00:00` without considering leap years/seconds
        and days count in months (always 31 day)

        Args:
            dt (datetime): datetime object to convert

        Returns:
            int: ZK ctime integer value

        &#34;&#34;&#34;
        if dt.year &lt; 2000:
            raise ValueError(&#39;Cannot get zkctime from a date earlier than a midnight of 2000-01-01&#39;)

        return sum((
            sum((
                (dt.year - 2000) * 12 * 31,
                (dt.month - 1) * 31,
                (dt.day - 1)
            )) * 24 * 60 * 60,
            dt.hour * 60 * 60,
            dt.minute * 60,
            dt.second
        ))

    @staticmethod
    def time_string_to_datetime(dt_string: str) -&gt; datetime:
        &#34;&#34;&#34;Parses datetime string and return datetime object. Such value
        is used in events list. Datetime string has ISO date format.

        Args:
            dt_string (str): datetime string, e.g. `2021-04-15 21:21:00`

        Returns:
            datetime: converted datetime object

        &#34;&#34;&#34;
        return datetime.strptime(dt_string, &#39;%Y-%m-%d %H:%M:%S&#39;)

    @staticmethod
    def zktimerange_to_times(zktr: Union[str, int]) -&gt; Tuple[time, time]:
        &#34;&#34;&#34;Decode 4-byte time range into time objects couple.
        Such approach is used in Timezone table.

        Simply put, the higher 2 bytes are &#34;from&#34; part of range,
        the lower 2 bytes are &#34;to&#34; part. Time part is encoded as
        `(hour * 100) + minutes`.

        Args:
            zktr (Union[str, int]): encoded time range as integer or
                as number in string

        Returns:
            Tuple[time, time]: 2-tuple of from-tp time objects
                (without timezone)

        &#34;&#34;&#34;
        if isinstance(zktr, str):
            zktr = int(zktr)

        if zktr &lt; 0:
            raise ValueError(&#39;time range cannot be a negative number&#39;)

        to_num = zktr &amp; 0xffff
        from_num = (zktr &gt;&gt; 16) &amp; 0xffff
        from_t = time(hour=from_num // 100, minute=from_num % 100)
        to_t = time(hour=to_num // 100, minute=to_num % 100)

        return from_t, to_t

    @staticmethod
    def times_to_zktimerange(from_t: Union[datetime, time], to_t: Union[datetime, time]) -&gt; int:
        &#34;&#34;&#34;Encode time range in time/datetime objects into one 4-byte
        integer. Such approach is used in Timezone table.

        Simply put, the higher 2 bytes are &#34;from&#34; part of range,
        the lower 2 bytes are &#34;to&#34; part. Time part is encoded as
        `(hour * 100) + minutes`.

        Args:
            from_t (Union[datetime, time]): time/datetime &#34;from&#34; part
                of time range
            to_t (Union[datetime, time]): time/datetime &#34;to&#34; part
                of time range

        Returns:
            int: encoded 4-byte integer

        &#34;&#34;&#34;
        return ((from_t.hour * 100 + from_t.minute) &lt;&lt; 16) + (to_t.hour * 100 + to_t.minute)

    @staticmethod
    def zkdate_to_date(zkd: str) -&gt; Optional[date]:
        &#34;&#34;&#34;Parse date string and return date object. Such format is
        used in User table.

        Date format is simple: &#39;YYYYMMDD&#39;

        Args:
            zkd (str): date string

        Returns:
            Optional[date]: parsed date object

        &#34;&#34;&#34;
        # Device can return &#39;0&#39; string for date fields
        if zkd == &#39;0&#39;:
            return None

        return datetime.strptime(zkd, &#39;%Y%m%d&#39;).date()

    @staticmethod
    def date_to_zkdate(d: Union[date, datetime]) -&gt; str:
        &#34;&#34;&#34;Make a date string from a given date/datetime object. Such
        format is used in User table.

        Date format is simple: &#39;YYYYMMDD&#39;

        Args:
            d (Union[date, datetime]): date/datetime object

        Returns:
            str: date string

        &#34;&#34;&#34;
        return d.strftime(&#39;%Y%m%d&#39;)

    @staticmethod
    def zktimemoment_to_datetime(zktm: Union[str, int]) -&gt; Optional[datetime]:
        &#34;&#34;&#34;Decode 4-byte time annual time moment to a datetime with
        year and timezone ignored. Such approach is used in
        DaylightSavingTime, StandardTime parameters.

        Simply put, each byte represents time piece in order: month,
        day, hour, minute

        Args:
            zktm: (Union[str, int]): encoded annual time moment as
                integer or as number in string

        Returns:
            datetime: decoded datetime object
        &#34;&#34;&#34;
        if zktm in (&#39;0&#39;, 0):
            return None

        if isinstance(zktm, str):
            zktm = int(zktm)

        return datetime(
            year=1970,
            month=(zktm &gt;&gt; 24) &amp; 0xff,
            day=(zktm &gt;&gt; 16) &amp; 0xff,
            hour=(zktm &gt;&gt; 8) &amp; 0xff,
            minute=zktm &amp; 0xff
        )

    @staticmethod
    def datetime_to_zktimemoment(dt: datetime) -&gt; int:
        &#34;&#34;&#34;Encode time moment in datetime object into a 4-byte integer
        used in a device as annual time moment representation. Year and
        timezone will be ignored. Such approach is used in
        DaylightSavingTime, StandardTime parameters.

        Args:
            dt: datetime object

        Returns:
            int: encoded annual time moment
        &#34;&#34;&#34;
        return int((dt.month &lt;&lt; 24) | (dt.day &lt;&lt; 16) | (dt.hour &lt;&lt; 8) | dt.minute)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyzkaccess.common.ZKDatetimeUtils.date_to_zkdate"><code class="name flex">
<span>def <span class="ident">date_to_zkdate</span></span>(<span>d: Union[datetime.date, datetime.datetime]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Make a date string from a given date/datetime object. Such
format is used in User table.</p>
<p>Date format is simple: 'YYYYMMDD'</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>Union[date, datetime]</code></dt>
<dd>date/datetime object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>date string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def date_to_zkdate(d: Union[date, datetime]) -&gt; str:
    &#34;&#34;&#34;Make a date string from a given date/datetime object. Such
    format is used in User table.

    Date format is simple: &#39;YYYYMMDD&#39;

    Args:
        d (Union[date, datetime]): date/datetime object

    Returns:
        str: date string

    &#34;&#34;&#34;
    return d.strftime(&#39;%Y%m%d&#39;)</code></pre>
</details>
</dd>
<dt id="pyzkaccess.common.ZKDatetimeUtils.datetime_to_zkctime"><code class="name flex">
<span>def <span class="ident">datetime_to_zkctime</span></span>(<span>dt: datetime.datetime) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Converts datetime object to a ZK-specific ctime value.
Such type can be found in device parameters and data tables.</p>
<p>Simply put this ctime is a count of seconds starting from
<code>2000-01-01 00:00:00</code> without considering leap years/seconds
and days count in months (always 31 day)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong> :&ensp;<code>datetime</code></dt>
<dd>datetime object to convert</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>ZK ctime integer value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def datetime_to_zkctime(dt: datetime) -&gt; int:
    &#34;&#34;&#34;Converts datetime object to a ZK-specific ctime value.
    Such type can be found in device parameters and data tables.

    Simply put this ctime is a count of seconds starting from
    `2000-01-01 00:00:00` without considering leap years/seconds
    and days count in months (always 31 day)

    Args:
        dt (datetime): datetime object to convert

    Returns:
        int: ZK ctime integer value

    &#34;&#34;&#34;
    if dt.year &lt; 2000:
        raise ValueError(&#39;Cannot get zkctime from a date earlier than a midnight of 2000-01-01&#39;)

    return sum((
        sum((
            (dt.year - 2000) * 12 * 31,
            (dt.month - 1) * 31,
            (dt.day - 1)
        )) * 24 * 60 * 60,
        dt.hour * 60 * 60,
        dt.minute * 60,
        dt.second
    ))</code></pre>
</details>
</dd>
<dt id="pyzkaccess.common.ZKDatetimeUtils.datetime_to_zktimemoment"><code class="name flex">
<span>def <span class="ident">datetime_to_zktimemoment</span></span>(<span>dt: datetime.datetime) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Encode time moment in datetime object into a 4-byte integer
used in a device as annual time moment representation. Year and
timezone will be ignored. Such approach is used in
DaylightSavingTime, StandardTime parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong></dt>
<dd>datetime object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>encoded annual time moment</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def datetime_to_zktimemoment(dt: datetime) -&gt; int:
    &#34;&#34;&#34;Encode time moment in datetime object into a 4-byte integer
    used in a device as annual time moment representation. Year and
    timezone will be ignored. Such approach is used in
    DaylightSavingTime, StandardTime parameters.

    Args:
        dt: datetime object

    Returns:
        int: encoded annual time moment
    &#34;&#34;&#34;
    return int((dt.month &lt;&lt; 24) | (dt.day &lt;&lt; 16) | (dt.hour &lt;&lt; 8) | dt.minute)</code></pre>
</details>
</dd>
<dt id="pyzkaccess.common.ZKDatetimeUtils.time_string_to_datetime"><code class="name flex">
<span>def <span class="ident">time_string_to_datetime</span></span>(<span>dt_string: str) ‑> datetime.datetime</span>
</code></dt>
<dd>
<div class="desc"><p>Parses datetime string and return datetime object. Such value
is used in events list. Datetime string has ISO date format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt_string</code></strong> :&ensp;<code>str</code></dt>
<dd>datetime string, e.g. <code>2021-04-15 21:21:00</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime</code></dt>
<dd>converted datetime object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def time_string_to_datetime(dt_string: str) -&gt; datetime:
    &#34;&#34;&#34;Parses datetime string and return datetime object. Such value
    is used in events list. Datetime string has ISO date format.

    Args:
        dt_string (str): datetime string, e.g. `2021-04-15 21:21:00`

    Returns:
        datetime: converted datetime object

    &#34;&#34;&#34;
    return datetime.strptime(dt_string, &#39;%Y-%m-%d %H:%M:%S&#39;)</code></pre>
</details>
</dd>
<dt id="pyzkaccess.common.ZKDatetimeUtils.times_to_zktimerange"><code class="name flex">
<span>def <span class="ident">times_to_zktimerange</span></span>(<span>from_t: Union[datetime.datetime, datetime.time], to_t: Union[datetime.datetime, datetime.time]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Encode time range in time/datetime objects into one 4-byte
integer. Such approach is used in Timezone table.</p>
<p>Simply put, the higher 2 bytes are "from" part of range,
the lower 2 bytes are "to" part. Time part is encoded as
<code>(hour * 100) + minutes</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>from_t</code></strong> :&ensp;<code>Union[datetime, time]</code></dt>
<dd>time/datetime "from" part
of time range</dd>
<dt><strong><code>to_t</code></strong> :&ensp;<code>Union[datetime, time]</code></dt>
<dd>time/datetime "to" part
of time range</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>encoded 4-byte integer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def times_to_zktimerange(from_t: Union[datetime, time], to_t: Union[datetime, time]) -&gt; int:
    &#34;&#34;&#34;Encode time range in time/datetime objects into one 4-byte
    integer. Such approach is used in Timezone table.

    Simply put, the higher 2 bytes are &#34;from&#34; part of range,
    the lower 2 bytes are &#34;to&#34; part. Time part is encoded as
    `(hour * 100) + minutes`.

    Args:
        from_t (Union[datetime, time]): time/datetime &#34;from&#34; part
            of time range
        to_t (Union[datetime, time]): time/datetime &#34;to&#34; part
            of time range

    Returns:
        int: encoded 4-byte integer

    &#34;&#34;&#34;
    return ((from_t.hour * 100 + from_t.minute) &lt;&lt; 16) + (to_t.hour * 100 + to_t.minute)</code></pre>
</details>
</dd>
<dt id="pyzkaccess.common.ZKDatetimeUtils.zkctime_to_datetime"><code class="name flex">
<span>def <span class="ident">zkctime_to_datetime</span></span>(<span>zkctime: Union[str, int]) ‑> datetime.datetime</span>
</code></dt>
<dd>
<div class="desc"><p>Convert ZK-specific ctime integer value to a datetime object.</p>
<p>Simply put this ctime is a count of seconds starting from
<code>2000-01-01 00:00:00</code> without considering leap years/seconds
and days count in months (always 31 day)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zkctime</code></strong> :&ensp;<code>Union[str, int]</code></dt>
<dd>ZK ctime integer or string value</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime</code></dt>
<dd>converted datetime</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def zkctime_to_datetime(zkctime: Union[str, int]) -&gt; datetime:
    &#34;&#34;&#34;Convert ZK-specific ctime integer value to a datetime object.

    Simply put this ctime is a count of seconds starting from
    `2000-01-01 00:00:00` without considering leap years/seconds
    and days count in months (always 31 day)

    Args:
        zkctime (Union[str, int]): ZK ctime integer or string value

    Returns:
        datetime: converted datetime

    &#34;&#34;&#34;
    if isinstance(zkctime, str):
        zkctime = int(zkctime)

    if zkctime &lt; 0:
        raise ValueError(&#39;Value must be a positive number&#39;)

    return datetime(
        year=zkctime // 32140800 + 2000,
        month=(zkctime // 2678400) % 12 + 1,
        day=(zkctime // 86400) % 31 + 1,
        hour=(zkctime // 3600) % 24,
        minute=(zkctime // 60) % 60,
        second=zkctime % 60
    )</code></pre>
</details>
</dd>
<dt id="pyzkaccess.common.ZKDatetimeUtils.zkdate_to_date"><code class="name flex">
<span>def <span class="ident">zkdate_to_date</span></span>(<span>zkd: str) ‑> Optional[datetime.date]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse date string and return date object. Such format is
used in User table.</p>
<p>Date format is simple: 'YYYYMMDD'</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zkd</code></strong> :&ensp;<code>str</code></dt>
<dd>date string</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[date]</code></dt>
<dd>parsed date object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def zkdate_to_date(zkd: str) -&gt; Optional[date]:
    &#34;&#34;&#34;Parse date string and return date object. Such format is
    used in User table.

    Date format is simple: &#39;YYYYMMDD&#39;

    Args:
        zkd (str): date string

    Returns:
        Optional[date]: parsed date object

    &#34;&#34;&#34;
    # Device can return &#39;0&#39; string for date fields
    if zkd == &#39;0&#39;:
        return None

    return datetime.strptime(zkd, &#39;%Y%m%d&#39;).date()</code></pre>
</details>
</dd>
<dt id="pyzkaccess.common.ZKDatetimeUtils.zktimemoment_to_datetime"><code class="name flex">
<span>def <span class="ident">zktimemoment_to_datetime</span></span>(<span>zktm: Union[str, int]) ‑> Optional[datetime.datetime]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode 4-byte time annual time moment to a datetime with
year and timezone ignored. Such approach is used in
DaylightSavingTime, StandardTime parameters.</p>
<p>Simply put, each byte represents time piece in order: month,
day, hour, minute</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zktm</code></strong></dt>
<dd>(Union[str, int]): encoded annual time moment as
integer or as number in string</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime</code></dt>
<dd>decoded datetime object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def zktimemoment_to_datetime(zktm: Union[str, int]) -&gt; Optional[datetime]:
    &#34;&#34;&#34;Decode 4-byte time annual time moment to a datetime with
    year and timezone ignored. Such approach is used in
    DaylightSavingTime, StandardTime parameters.

    Simply put, each byte represents time piece in order: month,
    day, hour, minute

    Args:
        zktm: (Union[str, int]): encoded annual time moment as
            integer or as number in string

    Returns:
        datetime: decoded datetime object
    &#34;&#34;&#34;
    if zktm in (&#39;0&#39;, 0):
        return None

    if isinstance(zktm, str):
        zktm = int(zktm)

    return datetime(
        year=1970,
        month=(zktm &gt;&gt; 24) &amp; 0xff,
        day=(zktm &gt;&gt; 16) &amp; 0xff,
        hour=(zktm &gt;&gt; 8) &amp; 0xff,
        minute=zktm &amp; 0xff
    )</code></pre>
</details>
</dd>
<dt id="pyzkaccess.common.ZKDatetimeUtils.zktimerange_to_times"><code class="name flex">
<span>def <span class="ident">zktimerange_to_times</span></span>(<span>zktr: Union[str, int]) ‑> Tuple[datetime.time, datetime.time]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode 4-byte time range into time objects couple.
Such approach is used in Timezone table.</p>
<p>Simply put, the higher 2 bytes are "from" part of range,
the lower 2 bytes are "to" part. Time part is encoded as
<code>(hour * 100) + minutes</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zktr</code></strong> :&ensp;<code>Union[str, int]</code></dt>
<dd>encoded time range as integer or
as number in string</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[time, time]</code></dt>
<dd>2-tuple of from-tp time objects
(without timezone)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def zktimerange_to_times(zktr: Union[str, int]) -&gt; Tuple[time, time]:
    &#34;&#34;&#34;Decode 4-byte time range into time objects couple.
    Such approach is used in Timezone table.

    Simply put, the higher 2 bytes are &#34;from&#34; part of range,
    the lower 2 bytes are &#34;to&#34; part. Time part is encoded as
    `(hour * 100) + minutes`.

    Args:
        zktr (Union[str, int]): encoded time range as integer or
            as number in string

    Returns:
        Tuple[time, time]: 2-tuple of from-tp time objects
            (without timezone)

    &#34;&#34;&#34;
    if isinstance(zktr, str):
        zktr = int(zktr)

    if zktr &lt; 0:
        raise ValueError(&#39;time range cannot be a negative number&#39;)

    to_num = zktr &amp; 0xffff
    from_num = (zktr &gt;&gt; 16) &amp; 0xffff
    from_t = time(hour=from_num // 100, minute=from_num % 100)
    to_t = time(hour=to_num // 100, minute=to_num % 100)

    return from_t, to_t</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyzkaccess" href="index.html">pyzkaccess</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyzkaccess.common.DocDict" href="#pyzkaccess.common.DocDict">DocDict</a></code></h4>
</li>
<li>
<h4><code><a title="pyzkaccess.common.UserTuple" href="#pyzkaccess.common.UserTuple">UserTuple</a></code></h4>
<ul class="">
<li><code><a title="pyzkaccess.common.UserTuple.copy" href="#pyzkaccess.common.UserTuple.copy">copy</a></code></li>
<li><code><a title="pyzkaccess.common.UserTuple.count" href="#pyzkaccess.common.UserTuple.count">count</a></code></li>
<li><code><a title="pyzkaccess.common.UserTuple.index" href="#pyzkaccess.common.UserTuple.index">index</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyzkaccess.common.ZKDatetimeUtils" href="#pyzkaccess.common.ZKDatetimeUtils">ZKDatetimeUtils</a></code></h4>
<ul class="">
<li><code><a title="pyzkaccess.common.ZKDatetimeUtils.date_to_zkdate" href="#pyzkaccess.common.ZKDatetimeUtils.date_to_zkdate">date_to_zkdate</a></code></li>
<li><code><a title="pyzkaccess.common.ZKDatetimeUtils.datetime_to_zkctime" href="#pyzkaccess.common.ZKDatetimeUtils.datetime_to_zkctime">datetime_to_zkctime</a></code></li>
<li><code><a title="pyzkaccess.common.ZKDatetimeUtils.datetime_to_zktimemoment" href="#pyzkaccess.common.ZKDatetimeUtils.datetime_to_zktimemoment">datetime_to_zktimemoment</a></code></li>
<li><code><a title="pyzkaccess.common.ZKDatetimeUtils.time_string_to_datetime" href="#pyzkaccess.common.ZKDatetimeUtils.time_string_to_datetime">time_string_to_datetime</a></code></li>
<li><code><a title="pyzkaccess.common.ZKDatetimeUtils.times_to_zktimerange" href="#pyzkaccess.common.ZKDatetimeUtils.times_to_zktimerange">times_to_zktimerange</a></code></li>
<li><code><a title="pyzkaccess.common.ZKDatetimeUtils.zkctime_to_datetime" href="#pyzkaccess.common.ZKDatetimeUtils.zkctime_to_datetime">zkctime_to_datetime</a></code></li>
<li><code><a title="pyzkaccess.common.ZKDatetimeUtils.zkdate_to_date" href="#pyzkaccess.common.ZKDatetimeUtils.zkdate_to_date">zkdate_to_date</a></code></li>
<li><code><a title="pyzkaccess.common.ZKDatetimeUtils.zktimemoment_to_datetime" href="#pyzkaccess.common.ZKDatetimeUtils.zktimemoment_to_datetime">zktimemoment_to_datetime</a></code></li>
<li><code><a title="pyzkaccess.common.ZKDatetimeUtils.zktimerange_to_times" href="#pyzkaccess.common.ZKDatetimeUtils.zktimerange_to_times">zktimerange_to_times</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>